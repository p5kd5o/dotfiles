## ~/.bashrc : bash config for interactive shells
## Patrick DeYoreo

## This file is sourced by all *interactive* bash shells on startup,
## including some apparently interactive shells such as scp and rcp
## that can't tolerate any output.
## Make sure this doesn't display anything or bad things will happen!

## Test for an interactive shell
[[ $- != *i* ]] && return

## Synchronize LINES and COLUMNS if DISPLAY is set
[[ -v DISPLAY ]] && shopt -s checkwinsize

## ERR trap is inherited by functions, command substitutions, & subshells
set -o errtrace
## The '>|' redirection operator is required to overwrite existing files
set -o noclobber
## Exit status of a pipeline is that of its last command to return non-zero
set -o pipefail

## Directory names entered as a commands will be passed to 'cd'
shopt -s autocd
## Correct minor errors the spelling of a directory name passed to 'cd'
shopt -s cdspell
## Check that a cmd found in the hash table exists before trying to execute it
shopt -s checkhash
## List jobs before exit and if any are running defer exit until 2nd attempt
shopt -s checkjobs
## Attempt to save all lines of a multiline cmd in the same history entry
shopt -s cmdhist
## Replace directory names with expansion results when completing filenames
shopt -s direxpand
## Attempt to correct spelling of non-existent dirs during word completion
shopt -s dirspell
## Enable extended pattern matching features - e.g. {!?@*+}(s1[|s2]...)
shopt -s extglob
## ** matches all files and directories; **/ matches directories only
shopt -s globstar
## Append the history list to the history file rather than overwriting it
shopt -s histappend
## Allow user to re-edit a failed history substitution (requires readline)
shopt -s histreedit
## Load history substitution results into editing buffer (requires readline)
shopt -s histverify
## Send SIGHUP (1) to all jobs when an interactive login shell exits
shopt -s huponexit
## If job control is off the last cmd of a pipeline is run in the current shell
shopt -s lastpipe
## If cmdhist is enabled multiline commands are saved with embedded newlines
shopt -s lithist

## Set the location of history file
HISTFILE=~/.shell_history
## Set the maximum length of the history file
HISTFILESIZE=50000
## Allow an unlimited number of entries in memory
HISTSIZE=-1
## Remove duplicates from the history list
HISTCONTROL='erasedups'
## Ignore immediate dups and lines beginning with a no-op/semicolon pair
HISTIGNORE='*([[:space:]])&*([[:space:]]):*([[:space:]])\:*([[:space:]]);*'
## Set a timestamp format (1999-12-31 23:59:59 -0000)
HISTTIMEFORMAT='%F %T %z'

## Ignore current (.) and parent (..) when globbing
GLOBIGNORE='?(*/).?(.)'
## Limit depth of paths generated by '\w' during prompt expansion
PROMPT_DIRTRIM=4


## Create an array to hold terminal info and escape sequences
declare -A ti=( ['bold']="$(tput bold)" ['dim']="$(tput dim)"
                ['sitm']="$(tput sitm)" ['ritm']="$(tput ritm)"
                ['smso']="$(tput rmso)" ['rmso']="$(tput rmso)"
                ['smul']="$(tput smul)" ['rmul']="$(tput rmul)"
                ['sgr0']="$(tput sgr0)" ['colors']="$(tput colors)" )


## Function to update the primary prompt (PS1)
PS1() {
  PS1=\
"${1-"\\[${ti[sgr0]}\\]"}"\
'$(tput rep '"$(("$(printf '%d' "'${2-"#"}")"))"' "$(("$(tput cols)"))")'\
'\['"${ti[sgr0]}"'\]\n'\
'\['"${ti[sgr0]}${ti[bold]}"'\]\u'\
'\['"${ti[dim]}"'\]@'\
'\['"${ti[sgr0]}${ti[bold]}"'\]\h'\
'\['"${ti[dim]}"'\]:'\
'\['"${ti[sgr0]}${ti[bold]}"'\]\w'\
'\['"${ti[sgr0]}"'\]\n'\
'\['"${ti[sgr0]}${ti[bold]}"'\]\D{%A %B %d %Y}'\
'\['"${ti[sgr0]}"'\]\n'\
'\['"${ti[sgr0]}${ti[bold]}"'\]\D{%I:%M %p %Z}'\
'\['"${ti[sgr0]}"'\]\n'\
'\['"${ti[sgr0]}${ti[bold]}"'\]\$'"${3-"λ"}"\
'\['"${ti[sgr0]}"'\] '
}
declare -ft PS1


## Function to update the secondary prompt (PS2)
PS2() {
  PS2=\
"${1-"\\[${ti[sgr0]}\\]"}"\
'$(( (LINENO - '"$(("${2-"${BASH_LINENO[-1]}"}"))"') / 10 ))'\
'$(( (LINENO - '"$(("${2-"${BASH_LINENO[-1]}"}"))"') % 10 ))'\
'\['"${ti[sgr0]}"'\] '
}
declare -ft PS2


## Select-loop prompt (does not undergo expansion)
PS3() {
  PS3="${1-"•◆"} "
}
declare -ft PS3


## Execution-trace prompt
PS4() {
  PS4=\
"${1-"\\[${ti[sgr0]}\\]"}"\
"${2-"•"}"\
'\['"${ti[sgr0]}${ti[bold]}"'\]'\
"${3-"◆"}"\
'\['"${ti[sgr0]}"'\] '
}
declare -ft PS4


## Function to update prompts
PS_update() {
  set -- "$(tput setaf "$(( ($?+123) % $(("${ti[colors]:=$(tput colors)}")) ))")"
  PS1 '\['"${ti[sgr0]}${ti[dim]}$1"'\]' '~' 'λ'
  PS2 '\['"${ti[sgr0]}${ti[bold]}${ti[dim]}$1"'\]' "${BASH_LINENO[-1]}"
  PS3 '•◆'
  PS4 '\['"${ti[sgr0]}${ti[bold]}${ti[dim]}$1"'\]' '•' '◆'
}
declare -ft PS_update


## Update prompt strings before printing primary prompt
PROMPT_COMMAND='PS_update'

## Update window title before printing primary prompt
case ${TERM} in
  xterm*|rxvt*|Eterm|aterm|kterm|gnome*)
    PROMPT_COMMAND+=${PROMPT_COMMAND:+; }\
'printf "\033]0;%s@%s:%s\007" "${USER}" "${HOSTNAME%%.*}" "${PWD/#$HOME/\~}"'
    ;;
  screen*|tmux*)
    PROMPT_COMMAND+=${PROMPT_COMMAND:+; }\
'printf "\033_%s@%s:%s\033\\" "${USER}" "${HOSTNAME%%.*}" "${PWD/#$HOME/\~}"'
    ;;
esac

## Load additional completion functions
[[ -r /usr/share/bash-completion/bash_completion  ]] \
  && . /usr/share/bash-completion/bash_completion

## Load any additional config
[[ -d ~/.bashrc.d ]] &&
  for _ in ~/.bashrc.d/?*; do
    [[ -r "$_" ]] && . "$_"
  done

## -- end --
