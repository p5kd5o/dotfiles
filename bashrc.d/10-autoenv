#!/bin/env bash
## Library of functions to help configure the environment

## Each arg matching a function in autoenv will cause a call to that function
## with the result of an indirect expansion on arg[@] as its parameter(s)
autoenv::main() {
  for _ in EDITOR LS_COLORS GCC_COLORS; do
    declare -p "$_" || autoenv::"${_%'[@]'}"
  done > /dev/null 2>&1 
}


## Sets a default text editor
autoenv::EDITOR() 
if unset -v EDITOR && local -a EDITOR=(vim nano); then
  for EDITOR in "$@" "${EDITOR[@]}"; do
    if read -r EDITOR < <(command -pv "${EDITOR}"); then
      declare -gx EDITOR="${EDITOR}"
      return
    fi
  done
fi


## Sets command output colors
autoenv::LS_COLORS()
if wait $! && unset -v LS_COLORS; then
  read -r LS_COLORS
  if (( $# )); then
    set -- "$1"
  elif [[ -f ~/.dircolors ]]; then
    set -- ~/.dircolors
  fi
  [[ "$("${LS_COLORS}" -b "$@")" =~ ^LS_COLORS=\'([^\']*)\' ]]
  declare -gx LS_COLORS="${BASH_REMATCH[1]}"
fi < <(command -pv dircolors)


## Sets GCC output formatting
autoenv::GCC_COLORS()
if local IFS=: && unset -v GCC_COLORS && local -A GCC_COLORS=( 
    ['caret']='caret=01;32' ['error']='error=01;31'
    ['locus']='locus=01'    ['note']='note=01;36'
    ['quote']='quote=01'    ['warning']='warning=01;35'
  );
then
    while (( $# )); do
      : "${1%%=*}"
      GCC_COLORS["$_"]="$_${1#"$_"}"
      shift
    done
    declare -gx GCC_COLORS="${GCC_COLORS[*]}"
fi


## Apply environment config
autoenv::main "$@"

## -- END --
