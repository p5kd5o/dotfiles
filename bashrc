#
## ~/.bashrc : initialization file for interactive shells
# bash 4.4.19
 

## Is this an interactive shell? If not, stop.
[[ $- != *i* ]] && return


## Initialize LINES and COLUMNS
kill -s 28 $$

## If DISPLAY is non-null, sync LINES and COLUMNS after each command
[[ -n ${DISPLAY} ]] && shopt -s checkwinsize



{ ## Set GPG_TTY to the current tty (if there is one)
  export GPG_TTY="$(command -p tty)"

  ## Refresh gpg-agent in case user switched to an Xsession
  command -p gpg-connect-agent updatestartuptty /bye
} 1>/dev/null 2>&1



## Functions, cmd substitutions, and subshells inherit traps on 'ERR' 
set -o errtrace

## Require the >| operator to overwrite existing files by redirection
set -o noclobber


## If the name of a directory is given as a command, pass it to cd
shopt -s autocd

## Check that a command found in the hashtable exists before running it
shopt -s checkhash

## Show jobs before exiting and require confirmation if any are running
shopt -s checkjobs

## Attempt to save each multiline command as a single history entry
shopt -s cmdhist

## Expand the name of a directory upon performing filename completion
shopt -s direxpand

## Attempt to correct mispelled directory names during word completion
shopt -s dirspell

## Enable extended pattern matching features
shopt -s extglob

## Range expressions used in bracket expressions behave as in the C locale 
shopt -s globasciiranges

## Let ``**`` match all files and 0 or more directories and subdirectories
shopt -s globstar

## Send SIGHUP(1) to all jobs when an interactive login shell exits
shopt -s huponexit

## Append to the history file instead of overwriting it
shopt -s histappend

## If using rl, allow user to re-edit a failed history substitution
shopt -s histreedit

## If using rl, load history substitutions into the editing buffer
shopt -s histverify

## Command substitutions inherit the value of the 'errexit' option
shopt -s inherit_errexit

## If job control is off, run the last cmd of a pipeline in the current shell
shopt -s lastpipe

## With 'cmdhist' enabled, save multiline commands with embedded newlines
shopt -s lithist


## Set EXECIGNORE to match shared object libraries
EXECIGNORE='?(?(+(/)usr)+(/))lib?(32|64))+(/)**/*.@(so*(.+( , ,[[:digit:]]))|dll)'

## Set GLOBIGNORE to match instances of ``.`` and ``..``
GLOBIGNORE='*(?(.)?(.|*)/).?(.)*(/)'

## Setting GLOBIGNORE enables 'dotglob' so disable it for 
shopt -u dotglob


## Configure the location of the history
if command -p mkdir --parents --mode 0700 "${XDG_DATA_HOME:-"${HOME}/.local/share"}/bash"
then
  HISTFILE="${XDG_DATA_HOME:-"${HOME}/.local/share"}/bash/history"
else
  HISTFILE="${HOME}/.bash_history"
fi


## Set max number of entries to keep on disk
HISTFILESIZE=10000

## Set max number of entries to keep in memory
HISTSIZE=-1

## Erase duplicate entries from the history
HISTCONTROL='erasedups'

## If 'extglob' is on, ignore dups regardless of surrounding whitespace
HISTIGNORE='*([[:blank:]])&*([[:blank:]])'


## Limit depth of paths generated by '\w' during prompt expansion
PROMPT_DIRTRIM=4


## Create an array to store terminal info
declare -A ti=( )


## Define function to set the primary prompt
function PS1() {
  PS1=\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
'\['"${ti['bold']:="$(tput bold)"}"'\]'\
'\['"${ti['dim']:="$(tput dim)"}"'\]'\
'\['"$1"'\]'\
'$(tput dl1; printf %.s— {1..'"$((COLUMNS?(COLUMNS):"$(tput cols)"))"'})'\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
'\n'\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
'\['"${ti['bold']:="$(tput bold)"}"'\]'\
'\u'\
'\['"${ti['dim']:="$(tput dim)"}"'\]'\
'@'\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
'\['"${ti['bold']:="$(tput bold)"}"'\]'\
'\h'\
'\['"${ti['dim']:="$(tput dim)"}"'\]'\
':'\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
'\['"${ti['bold']:="$(tput bold)"}"'\]'\
'\w'\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
'\n'\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
'\['"${ti['bold']:="$(tput bold)"}"'\]'\
'\D{%A %d %B %Y %I:%M %p}'\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
'\n'\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
'\['"${ti['bold']:="$(tput bold)"}"'\]'\
'\['"${ti['dim']:="$(tput dim)"}"'\]'\
'\['"$1"'\]'\
'\$λ'\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
' '
}


## Define function to set the secondary prompt
function PS2() {
  PS2=\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
'\['"${ti['bold']:="$(tput bold)"}"'\]'\
'\['"${ti['dim']:="$(tput dim)"}"'\]'\
'\['"$1"'\]'\
'$(( (LINENO - '"$(( BASH_LINENO[-1] ))"') / 10 ))'\
'$(( (LINENO - '"$(( BASH_LINENO[-1] ))"') % 10 ))'\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
' '
}


## Define function to set the select prompt
function PS3() {
   PS3="${PS3:-"•◆ "}"
}


## Define function to set the execution-trace prompt
function PS4() {
  PS4=\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
'\['"${ti['bold']:="$(tput bold)"}"'\]'\
'\['"${ti['dim']:="$(tput dim)"}"'\]'\
'•'\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
'\['"${ti['bold']:="$(tput bold)"}"'\]'\
'◆'\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
' '
}


function setPS() {
  ## Update the prompt strings before printing PS1
  if [[ $(($1)) -ne 0 ]]; then
    set -- "$(tput setaf "$(( ($(($1)) - 1) % 6 + 1 ))")"
  else
    set --
  fi

  PS1 "$1"
  PS2 "$1"
  PS3 "$1"
  PS4 "$1"
}


PROMPT_COMMAND='setPS "$?"'


## Set terminal window titles
case ${TERM} in
  xterm*|rxvt*|urxvt*|Eterm|aterm|kterm|gnome*)
    PROMPT_COMMAND+=${PROMPT_COMMAND:+; }\
'printf "\033]0;%s@%s:%s\007" "${USER}" "${HOSTNAME%%.*}" "${PWD/#${HOME}/\~}"'
    ;;
  screen*|tmux*)
    PROMPT_COMMAND+=${PROMPT_COMMAND:+; }\
'printf "\033_%s@%s:%s\033\\" "${USER}" "${HOSTNAME%%.*}" "${PWD/#${HOME}/\~}"'
    ;;
esac


## Load any additional profile config
[[ -d ~/.bashrc.d ]] && {
  for _ in ~/.bashrc.d/*; do
    [[ -f $_ ]] && . "$_"
  done
}
