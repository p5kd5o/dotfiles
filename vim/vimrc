" vimrc: vim initialization script

" Use vim defaults - not vi
if (&compatible)
  set nocompatible
endif

" Use vim defaults even if +eval is missing
silent! while (0)
set nocompatible
silent! endwhile


" Skip the rest in VSCode
if (exists('g:vscode'))
  finish
endif

" Always use UTF-8
set encoding=utf-8


"" Disable filetype plugins
" filetype off
"
"" Load plugins with pathogen
" try
"   execute pathogen#infect()
" catch /^Vim(execute):/
" endtry
" 
" " Enable filetype plugins & indentation style
" filetype plugin indent on
" 
" " Perform syntax highlighting
" if (has("syntax"))
"   syntax enable
" endif


" Load plugins with vim plug
"
call plug#begin(join(split(&runtimepath, ',')[:0] + ['plug'], '/'))
" NOTE: use single quotes around plugin names

Plug 'jlanzarotta/bufexplorer'
Plug 'ctrlpvim/ctrlp.vim'
Plug 'junegunn/fzf.vim'
Plug 'scrooloose/nerdtree'
Plug 'Xuyuanp/nerdtree-git-plugin'
Plug 'edkolev/promptline.vim'
Plug 'rust-lang/rust.vim'
Plug 'vim-syntastic/syntastic'
Plug 'edkolev/tmuxline.vim'
Plug 'rainglow/vim'
Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'
Plug 'flazz/vim-colorschemes'
Plug 'ryanoasis/vim-devicons'
Plug 'tpope/vim-fugitive'
Plug 'airblade/vim-gitgutter'
Plug 'pangloss/vim-javascript'
Plug 'rodjek/vim-puppet'
Plug 'tpope/vim-repeat'
Plug 'mhinz/vim-startify'
Plug 'tpope/vim-surround'


call plug#end()


" Clear vimrc autocommand group
augroup vimrc
  autocmd!
augroup END


" Tabs and Spaces

" Insert spaces insted of tab characters
set expandtab

" Number of columns reserved for line numbers
set numberwidth=3

" Number of spaces to use for an indent
set shiftwidth=2

" Number of spaces to insert for a tab
set softtabstop=2

" Visual width of a tab character (ASCII 0x09)
set tabstop=4

" Length past which lines will be broken automatically
set textwidth=79


" Display and Verbosity

" Display line numbers
set number

" Display line numbers relative to current line
set relativenumber

" Display cursor coordinates (e.g. LINE,COLUMN)
set ruler

" Display most recent command below window
set showcmd

" Briefly jump to match upon completing pair in 'matchpairs'
set showmatch

" Never hide status line
set laststatus=2

" Update terminal titles
set title

" Define terminal titles
let &titlestring = "%t%( [%M%R]%)%( (%{expand(\"%:p:~:h\")})%)%<"

" Show lines that don't fit as @@@ and nonprintable characters as hexadecimal
if (v:version >= 800)
  set display=truncate,uhex
endif

" Define a function to set 'colorcolumn' to match all columns past 'texwidth'
function UpdateColorColumn()
  if &textwidth
    if &number || &relativenumber
      let l:columns = winwidth(0) - &textwidth - &numberwidth
    else
      let l:columns = winwidth(0) - &textwidth
    endif
    if l:columns > 0
      let &colorcolumn = join(map(range(1, l:columns), '"+" . v:val'), ',')
    else
      let &colorcolumn = ''
    endif
  endif
endfunction

" Set 'colorcolumn' to match all columns past 'textwidth'
call UpdateColorColumn()

" Update 'colorcolumn' upon resizing window
autocmd vimrc VimEnter,VimResized * silent! call UpdateColorColumn()

autocmd vimrc OptionSet * silent!
  \ if <amatch> =~ '^\(\(no)\?relative\)\?\(number\|text\)\(width\)\?$'
  \ |  call UpdateColorColumn()
  \ |endif


" Window Splitting

" Split windows off toward to right
set splitright

" Split windows off down below
set splitbelow


" Buffer Behavior

" Re-read file if it was changed, unless it was deleted
set autoread

" Hide closed buffers rather than unloading them
set hidden


" Line Wrapping

" Do not wrap lines
"set nowrap

" Break lines before window edge
"set linebreak

" Indent wrapped lines
"set breakindent

" Break lines at these characters
"let &breakat = " \t;:"

" Prefix wrapped lines
"let &showbreak = "> "


" Pattern Matching

" Do not highlight search results
set nohlsearch

" Search forward as pattern is typed
set incsearch

" Ignore case by default
set ignorecase

" Respect case if pattern contains uppercase
set smartcase

" Additional bases recognized for increment/decrement
set nrformats=bin,hex


" Cursor Position

" Attempt to preserve cursor position when moving linewise
set nostartofline

" Allow backspacing over everything in insert mode
set backspace=indent,eol,start

" Lines of padding between cursor and edge of window
set scrolloff=3

" If 'nowrap' is set, minimum number of columnss to scroll at a time
set sidescroll=1

" If 'nowrap' is set, columns of padding between cursor and edge of window
set sidescrolloff=3

" Allow visual-block selection of empty columns
set virtualedit=block


" Completion

" Enable command completion
set wildmenu

" Ignore case for filename completion
set wildignorecase

" Tweak insert-mode completion
set completeopt=menu,preview,noselect

" Tweak command-mode completion
set wildmode=list:longest,full

" Use <Left> and <Right> to move cursor rather than selecting completions
cnoremap <Left>  <Space><BS><Left>
cnoremap <Right> <Space><BS><Right>


" Key Timeout

" Timeout on mappings and keycodes
set timeout

" milliseconds to wait for completion of a mapping
set timeoutlen=1000

" milliseconds to wait for completion of a key code
set ttimeoutlen=80


" History

" Number of search patterns and ``:'' commands to remember (max: 10000)
set history=10000

" Number of modifications to remember for a given file
set undolevels=2500

" Always save entire buffer for undo when reloading it
set undoreload=-1

" Max characters typed between swapfile syncs
set updatecount=40

" Max milliseconds elapsed between swapfile syncs (also used by gitgutter)
set updatetime=200


" Tags File Locations
let &tags = "./.tags,./tags,.tags,tags"

" Swapfile and Undofile

" Check undofile capability and use if using swapfile
if (has('persistent_undo'))
  let &undofile = &swapfile
endif

" Clear swap / undo directory preferences
set directory=
set   undodir=

" Append XDG_DATA_HOME if non-null
if ($XDG_DATA_HOME != '')
  set directory+=$XDG_DATA_HOME/vim/swap/
  set   undodir+=$XDG_DATA_HOME/vim/undo/
endif

" Append XDG_CACHE_HOME if non-null
if ($XDG_CACHE_HOME != '')
  set directory+=$XDG_CACHE_HOME/vim/swap/
  set   undodir+=$XDG_CACHE_HOME/vim/undo/
endif

" Append first element of 'runtimepath'
if !(empty(split(&runtimepath, ',')))
  if (&directory == '')
    let &directory = split(&runtimepath, ',')[0] . '/swap/'
  else
    let &directory .= ',' . split(&runtimepath, ',')[0] . '/swap/'
  endif
  if (&undodir == '')
    let &undodir = split(&runtimepath, ',')[0] . '/undo/'
  else
    let &undodir .= ',' . split(&runtimepath, ',')[0] . '/undo/'
  endif
endif

" Append default tmp directories
set directory+=/var/tmp/,/tmp/
set   undodir+=/var/tmp/,/tmp/

" Create the primary swap directory
if !(isdirectory(split(&directory, ',')[0]))
  silent! call mkdir(split(&directory, ',')[0], 'p', 0700)
endif

" Create the primary undo directory
if !(isdirectory(split(&undodir, ',')[0]))
  silent! call mkdir(split(&undodir, ',')[0], 'p', 0700)
endif


" Terminal

" F**k terminal bells
set belloff=all


" Mouse

" Enable the mouse
if (has('mouse'))
  set mouse=a
  if (has('mouse_sgr'))
    set ttymouse=sgr
  endif
endif


" Colors

" Set 'colors' cap
if !has('nvim')
  if $COLORTERM =~? '^truecolor$'
    let &t_Co = 16777216
  elseif $COLORTERM =~ '^rxvt-xpm$' || $TERM =~ '^.*-256color\%(-.*\)\?$'
    let &t_Co = 256
  endif
endif

" Try to guess color capabilities
if (exists('+termguicolors'))
  if $TERM =~ '^\%(rxvt\|screen\|interix\|putty\)\%(-.*\)\?$'
      set notermguicolors
  elseif $TERM =~ '^\%(iterm\|vte\|gnome\|st\)\%(-.*\)\?$'
    if !has('nvim')
      let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
      let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
    endif
    set termguicolors
  elseif $TERM =~ '^\%(tmux\|xterm\)\%(-.*\)\?$'
    if $XTERM_VERSION != '' || $VTE_VERSION != '' || $KONSOLE_PROFILE_NAME != ''
      if !has('nvim')
        let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
        let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
      endif
      set termguicolors
    else
      set notermguicolors
    endif
  else
    set notermguicolors
  endif
endif

" Choose some colors
if &termguicolors
  let g:colorschemes = [
    \   'neverland2-darker',
    \   'nightshimmer',
    \   'neverness',
    \   'candycode',
    \   'candy',
    \   'bubblegum',
    \ ]
else
  let g:colorschemes = []
endif

if &t_Co > 255
  let g:colorschemes = [
    \   'skittles_berry',
    \   'squidink',
    \   'desertink',
    \   'Tomorrow-Night-Eighties',
    \   '1989',
    \   'dracula',
    \   'Benokai',
    \   'vice',
    \   'brogrammer',
    \   'ego',
    \   'evolution',
    \   'lucius',
    \   'predawn',
    \ ]
else
  let g:colorschemes = [
    \   'peachpuff',
    \   'desert',
    \   'delek',
    \   'default'
    \ ]
endif
execute join(['colorscheme', g:colorschemes[0]])

" Define a function to rotate the colorscheme
function RotateColorscheme(n)
  if exists('g:colorschemes')
    try
      let l:start = index(g:colorschemes, g:colors_name)
    catch /^Vim(let)\=:E121/
      let l:start = -1
    endtry
    if l:start > -1
      let l:index = l:start + a:n
    else
      let l:index = 0
    endif
    while 1
      let l:index = l:index % len(g:colorschemes)
      try
        execute join(['colorscheme', g:colorschemes[l:index]])
      catch /^Vim(colorscheme):/
        if l:index != l:start + 1
          let l:index += 1
          continue
        endif
      endtry
      break
    endwhile
  endif
endfunction

" F8: Supercharge the current colorscheme
nnoremap <silent><F8> :
  \
  \if exists('g:colors_charged')<Bar>
  \ execute join(['colorscheme', g:colors_name])<Bar>
  \ unlet g:colors_charged<Bar>
  \else<Bar>
  \ execute join(['colorscheme', 'charge'])<Bar>
  \ let g:colors_charged = 1<Bar>
  \endif<CR>

" F9: Rotate to prev colorscheme with <Alt-Down>
nnoremap <silent><F9> :
  \
  \call RotateColorscheme(-1)<Bar>
  \if exists('g:colors_charged')<Bar>
  \ unlet g:colors_charged<Bar>
  \endif<CR>

" F10: Rotate to next colorscheme with <Alt-Up>
nnoremap <silent><F10> :
  \
  \call RotateColorscheme(1)<Bar>
  \if exists('g:colors_charged')<Bar>
  \ unlet g:colors_charged<Bar>
  \endif<CR>

" C / C++
" Recognize strings & numbers inside comments
let g:c_comment_strings = 1

" Highlight GNU specific items
let g:c_gnu = 1

" Highlight space errors
let g:c_space_errors = 1

" Set local options upon opening a C or C++ file
autocmd vimrc FileType c,cpp
  \ silent! setlocal cin noet cino=:0,(4 sts=0 sw=4 ts=4


" Gitcommit

" Set textwidth for commit messages
autocmd vimrc FileType gitcommit
  \ silent! setlocal tw=50


" Markdown

" Set local options for markdown documents (e.g. README, etc.)
autocmd vimrc FileType markdown
  \ silent! setlocal nonu nornu wrap lbr bri brk=" \t!@?({+-*/;:,."


" Man pages

" Load the Man plugin
runtime ftplugin/man.vim

" Use K to open man pages
set keywordprg=:Man

" Set local options for man pages
autocmd vimrc FileType man
  \ silent! setlocal noma nonu nornu nohid noswf noudf tw=0


" Python

" Set local options for python scripts
autocmd vimrc FileType python
  \ silent! setlocal et sts=4 sw=4 ts=8

" Enable all available highlighting
let g:python_highlight_all = 1

" Enable syntastic plugins
let g:syntastic_python_checkers = ['pep8', 'pylint', 'python3']

" Set the default version for pyx commands
if (has('pythonx'))
  if (has('python3'))
    set pyxversion=3
  elseif (has('python2'))
    set pyxversion=2
  endif
endif


" Readline

" Highlight bash additions
let g:readline_has_bash = 1


" Sed

" Highlight real tabs in sed scripts
let g:highlight_sedtabs = 1


" Sh

" Default highlighting for shell scripts
let g:is_posix = 1

" Fold functions and if/do/for clauses
let g:sh_fold_enabled = 3

" Relax error detection
let g:sh_no_error = 1

" Set local options when opening a shell script
autocmd vimrc FileType sh,zsh
  \ silent! setlocal et sts=2 sw=2 ts=4

" Set filetype to sh when editing a shell command line
autocmd vimrc BufRead bash-fc.?*
  \ silent! setlocal ft=sh noswf noudf
  \ |let b:is_bash = 1
  \ |syntax enable


" help

" Set local options when opening vim help
autocmd vimrc FileType help
  \ silent! setlocal noswf noudf


" CtrlSpace

let g:CtrlSpaceDefaultMappingKey = "<C-Space>"

" FZF
let g:fzf_colors = {
  \ 'fg':      ['fg', 'Normal'],
  \ 'bg':      ['bg', 'Normal'],
  \ 'hl':      ['fg', 'Comment'],
  \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
  \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
  \ 'hl+':     ['fg', 'Statement'],
  \ 'info':    ['fg', 'PreProc'],
  \ 'border':  ['fg', 'Ignore'],
  \ 'prompt':  ['fg', 'Conditional'],
  \ 'pointer': ['fg', 'Exception'],
  \ 'marker':  ['fg', 'Keyword'],
  \ 'spinner': ['fg', 'Label'],
  \ 'header':  ['fg', 'Comment'],
  \ }

" Syntastic

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 0
let g:syntastic_check_on_open = 0


" Airline

let g:airline_powerline_fonts = 1
let g:airline_left_sep = "\UE0C0"
let g:airline_right_sep = "\UE0C2"
let g:airline_left_alt_sep = "\UE0B1"
let g:airline_right_alt_sep = "\UE0B3"

if !(exists('g:airline_symbols'))
  let g:airline_symbols = {}
endif
let g:airline_symbols.branch = ''
let g:airline_symbols.crypt = ''
let g:airline_symbols.dirty = '  '
let g:airline_symbols.ellipsis = '…'
let g:airline_symbols.linenr = '﬌ '
let g:airline_symbols.maxlinenr = ''
let g:airline_symbols.modified = '  '
let g:airline_symbols.notexists = ''
let g:airline_symbols.readonly = ''
let g:airline_symbols.paste = ''
let g:airline_symbols.space = ' '
let g:airline_symbols.whitespace = ''
"let g:airline_symbols.readonly   = ''
"let g:airline_symbols.dirty      = ''
"let g:airline_symbols.crypt      = ''
"let g:airline_symbols.linenr     = ''
"let g:airline_symbols.maxlinenr  = ''
"let g:airline_symbols.spell      = ''
"let g:airline_symbols.whitespace = ''

let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#tabline#formatter = "unique_tail_improved"
let g:airline#extensions#tabline#overflow_marker = '…'
let g:airline#extensions#tabline#buffer_nr_show = 1
let g:airline#extensions#tabline#fnamecollapse = 1

" DevIcons
let g:webdevicons_enable = 1
let g:webdevicons_enable_nerdtree = 1
let g:webdevicons_enable_airline_tabline = 1
let g:webdevicons_enable_airline_statusline = 1
let g:webdevicons_enable_startify = 1
let g:webdevicons_gui_glyph_fix = 1
let g:webdevicons_conceal_nerdtree_brackets = 1
let g:WebDevIconsUnicodeDecorateFolderNodes = 1
let g:DevIconsEnableFoldersOpenClose = 1
let g:WebDevIconsNerdTreeGitPluginForceVAlign = 1

" Disable arrow icons at the left side of folder icons
let g:NERDTreeDirArrowExpandable  = "\u202f"
let g:NERDTreeDirArrowCollapsible = "\u202f"

" NERDTree git icons
let g:NERDTreeIndicatorMapCustom = {
    \   'Modified'  : '',
    \   'Staged'    : '',
    \   'Untracked' : '',
    \   'Renamed'   : '',
    \   'Unmerged'  : '',
    \   'Deleted'   : '',
    \   'Dirty'     : '',
    \   'Clean'     : '',
    \   'Ignored'   : '',
    \   'Unknown'   : '',
    \ }

" Put some Airline themes in a list
let g:airline_themes = [
    \   'base16_ashes',
    \   'biogoo',
    \   'atomic',
    \   'tomorrow',
    \   'behelit',
    \   'kolor',
    \   'owo',
    \   'base16_eighties',
    \ ]

" Set an Airline theme
let g:airline_theme = g:airline_themes[0]

" Define a function to rotate the Airline theme
function RotateAirlineTheme(n)
  if exists('g:airline_themes')
    try
      let l:start = index(g:airline_themes, g:airline_theme)
    catch /^Vim(let)\=:E121/
      let l:start = -1
    endtry
    if l:start > -1
      let l:index = l:start + a:n
    else
      let l:index = 0
    endif
    while 1
      let l:index = l:index % len(g:airline_themes)
      try
        execute join(['AirlineTheme', g:airline_themes[l:index]])
      catch /^Vim(AirlineTheme):/
        if l:index + 1 != l:start + 1
          let l:index += 1
          continue
        endif
      endtry
      break
    endwhile
  endif
endfunction

" Esc F9: Rotate to prev colorscheme with <Alt-Down>
nnoremap <silent><S-F9> :
  \
  \call RotateAirlineTheme(-1)<CR>

" Esc F10: Rotate to next colorscheme with <Alt-Up>
nnoremap <silent><S-F10> :
  \
  \call RotateAirlineTheme(1)<CR>

" Refresh airline when the colorscheme changes
autocmd vimrc ColorScheme *
  \
  \silent! AirlineRefresh


" Mappings

" Set a key to act as <leader> in mappings
let g:mapleader = ','

" Next tab
nnoremap <silent><M-Right> :
  \
  \tabnext<CR>

" Previous tab
nnoremap <silent><M-Left> :
  \
  \tabprev<CR>

" Create tab
nnoremap <silent><leader>c :
  \
  \tabnew<CR>

" Destroy tab
nnoremap <silent><leader>x :
  \
  \tabprev<CR>

" Insert: Toggle 'paste' mode
nnoremap <silent><Insert> :
  \
  \set paste!<CR>

set pastetoggle=<Insert>


" F6: Toggle line numbers
nnoremap <silent><F6> :
  \
  \let &l:nu = !&l:nu<Bar>
  \let &l:rnu = &l:nu<CR>

" F7: Toggle search highlighting
nnoremap <silent><F7> :
  \
  \setlocal hlsearch!<CR>

" Insert a shebang as the first line
nnoremap <silent><leader>#! ggI<C-R>=
  \
  \substitute(&filetype, "..*", "#!" . exepath(&filetype) . "\\r", "")<CR>
  \<ESC>``

" Search forward for the current visual selection
" Note: Jumping to a tag does not set the current search pattern
vnoremap <silent> * :
  \
  \<C-U>let old_reg=getreg('"')<Bar>
  \let old_regtype=getregtype('"')<CR>
  \gvy/<C-R><C-R>=
  \substitute(escape(@",'/\.*$^~['),'\_s\+','\\_s\\+','g')<CR><CR>
  \gV:call setreg('"',old_reg,old_regtype)<CR>

" Search backward for the current visual selection
" Note: Jumping to a tag does not set the current search pattern
vnoremap <silent> # :
  \
  \<C-U>let old_reg=getreg('"')<Bar>
  \let old_regtype=getregtype('"')<CR>
  \gvy?<C-R><C-R>=
  \substitute(escape(@",'?\.*$^~['),'\_s\+','\\_s\\+','g')<CR><CR>
  \gV:call setreg('"',old_reg,old_regtype)<CR>

" Map xterm sequences for <S-Arrow> combinations
map! <ESC>[1;2A <S-Up>
map! <ESC>[1;2B <S-Down>
map! <ESC>[1;2C <S-Right>
map! <ESC>[1;2D <S-Left>
nmap <ESC>[1;2A <S-Up>
nmap <ESC>[1;2B <S-Down>
nmap <ESC>[1;2C <S-Right>
nmap <ESC>[1;2D <S-Left>
vmap <ESC>[1;2A <S-Up>
vmap <ESC>[1;2B <S-Down>
vmap <ESC>[1;2C <S-Right>
vmap <ESC>[1;2D <S-Left>

" Map xterm sequences for <M-Arrow> combinations
map! <ESC>[1;3A <M-Up>
map! <ESC>[1;3B <M-Down>
map! <ESC>[1;3C <M-Right>
map! <ESC>[1;3D <M-Left>
nmap <ESC>[1;3A <M-Up>
nmap <ESC>[1;3B <M-Down>
nmap <ESC>[1;3C <M-Right>
nmap <ESC>[1;3D <M-Left>
vmap <ESC>[1;3A <M-Up>
vmap <ESC>[1;3B <M-Down>
vmap <ESC>[1;3C <M-Right>
vmap <ESC>[1;3D <M-Left>

" Map xterm sequences for <M-S-Arrow> combinations
map! <ESC>[1;4A <M-S-Up>
map! <ESC>[1;4B <M-S-Down>
map! <ESC>[1;4C <M-S-Right>
map! <ESC>[1;4D <M-S-Left>
nmap <ESC>[1;4A <M-S-Up>
nmap <ESC>[1;4B <M-S-Down>
nmap <ESC>[1;4C <M-S-Right>
nmap <ESC>[1;4D <M-S-Left>
vmap <ESC>[1;4A <M-S-Up>
vmap <ESC>[1;4B <M-S-Down>
vmap <ESC>[1;4C <M-S-Right>
vmap <ESC>[1;4D <M-S-Left>

" Map xterm sequences for <C-Arrow> combinations
map! <ESC>[1;5A <C-Up>
map! <ESC>[1;5B <C-Down>
map! <ESC>[1;5C <C-Right>
map! <ESC>[1;5D <C-Left>
nmap <ESC>[1;5A <C-Up>
nmap <ESC>[1;5B <C-Down>
nmap <ESC>[1;5C <C-Right>
nmap <ESC>[1;5D <C-Left>
vmap <ESC>[1;5A <C-Up>
vmap <ESC>[1;5B <C-Down>
vmap <ESC>[1;5C <C-Right>
vmap <ESC>[1;5D <C-Left>

" Map xterm sequences for <C-S-Arrow> combinations
map! <ESC>[1;6A <C-S-Up>
map! <ESC>[1;6B <C-S-Down>
map! <ESC>[1;6C <C-S-Right>
map! <ESC>[1;6D <C-S-Left>
nmap <ESC>[1;6A <C-S-Up>
nmap <ESC>[1;6B <C-S-Down>
nmap <ESC>[1;6C <C-S-Right>
nmap <ESC>[1;6D <C-S-Left>
vmap <ESC>[1;6A <C-S-Up>
vmap <ESC>[1;6B <C-S-Down>
vmap <ESC>[1;6C <C-S-Right>
vmap <ESC>[1;6D <C-S-Left>

" Map xterm sequences for <C-M-Arrow> combinations
map! <ESC>[1;7A <C-M-Up>
map! <ESC>[1;7B <C-M-Down>
map! <ESC>[1;7C <C-M-Right>
map! <ESC>[1;7D <C-M-Left>
nmap <ESC>[1;7A <C-M-Up>
nmap <ESC>[1;7B <C-M-Down>
nmap <ESC>[1;7C <C-M-Right>
nmap <ESC>[1;7D <C-M-Left>
vmap <ESC>[1;7A <C-M-Up>
vmap <ESC>[1;7B <C-M-Down>
vmap <ESC>[1;7C <C-M-Right>
vmap <ESC>[1;7D <C-M-Left>

" Map xterm sequences for <C-M-S-Arrow> combinations
map! <ESC>[1;8A <C-M-S-Up>
map! <ESC>[1;8B <C-M-S-Down>
map! <ESC>[1;8C <C-M-S-Right>
map! <ESC>[1;8D <C-M-S-Left>
nmap <ESC>[1;8A <C-M-S-Up>
nmap <ESC>[1;8B <C-M-S-Down>
nmap <ESC>[1;8C <C-M-S-Right>
nmap <ESC>[1;8D <C-M-S-Left>
vmap <ESC>[1;8A <C-M-S-Up>
vmap <ESC>[1;8B <C-M-S-Down>
vmap <ESC>[1;8C <C-M-S-Right>
vmap <ESC>[1;8D <C-M-S-Left>

" Map xterm sequences for <Fn> keys
map! <ESC>OP   <F1>
map! <ESC>OQ   <F2>
map! <ESC>OR   <F3>
map! <ESC>OS   <F4>
map! <ESC>[15~ <F5>
map! <ESC>[17~ <F6>
map! <ESC>[18~ <F7>
map! <ESC>[19~ <F8>
map! <ESC>[20~ <F9>
map! <ESC>[21~ <F10>
map! <ESC>[23~ <F11>
map! <ESC>[24~ <F12>
nmap <ESC>OP   <F1> 
nmap <ESC>OQ   <F2> 
nmap <ESC>OR   <F3> 
nmap <ESC>OS   <F4> 
nmap <ESC>[15~ <F5> 
nmap <ESC>[17~ <F6> 
nmap <ESC>[18~ <F7> 
nmap <ESC>[19~ <F8> 
nmap <ESC>[20~ <F9> 
nmap <ESC>[21~ <F10>
nmap <ESC>[23~ <F11>
nmap <ESC>[24~ <F12>
vmap <ESC>OP   <F1> 
vmap <ESC>OQ   <F2> 
vmap <ESC>OR   <F3> 
vmap <ESC>OS   <F4> 
vmap <ESC>[15~ <F5> 
vmap <ESC>[17~ <F6> 
vmap <ESC>[18~ <F7> 
vmap <ESC>[19~ <F8> 
vmap <ESC>[20~ <F9> 
vmap <ESC>[21~ <F10>
vmap <ESC>[23~ <F11>
vmap <ESC>[24~ <F12>

" Map xterm sequences for <S-Fn> combinations
map! <ESC>[23~   <S-F1>
map! <ESC>[24~   <S-F2>
map! <ESC>[1;2P  <S-F3>
map! <ESC>[1;2Q  <S-F4>
map! <ESC>[1;2R  <S-F5>
map! <ESC>[1;2S  <S-F6>
map! <ESC>[15;2~ <S-F7>
map! <ESC>[17;2~ <S-F8>
map! <ESC>[18;2~ <S-F9>
map! <ESC>[19;2~ <S-F10>
map! <ESC>[23;2~ <S-F11>
map! <ESC>[24;2~ <S-F12>
nmap <ESC>[23~   <S-F1>
nmap <ESC>[24~   <S-F2>
nmap <ESC>[1;2P  <S-F3>
nmap <ESC>[1;2Q  <S-F4>
nmap <ESC>[1;2R  <S-F5>
nmap <ESC>[1;2S  <S-F6>
nmap <ESC>[15;2~ <S-F7>
nmap <ESC>[17;2~ <S-F8>
nmap <ESC>[18;2~ <S-F9>
nmap <ESC>[19;2~ <S-F10>
nmap <ESC>[23;2~ <S-F11>
nmap <ESC>[24;2~ <S-F12>
vmap <ESC>[23~   <S-F1>
vmap <ESC>[24~   <S-F2>
vmap <ESC>[1;2P  <S-F3>
vmap <ESC>[1;2Q  <S-F4>
vmap <ESC>[1;2R  <S-F5>
vmap <ESC>[1;2S  <S-F6>
vmap <ESC>[15;2~ <S-F7>
vmap <ESC>[17;2~ <S-F8>
vmap <ESC>[18;2~ <S-F9>
vmap <ESC>[19;2~ <S-F10>
vmap <ESC>[23;2~ <S-F11>
vmap <ESC>[24;2~ <S-F12>

" End

" Allow options to be set from a modeline
set modeline

" Restrict editor if SWIM owns this file (should be last in vimrc)
set secure


" vi:et:ft=vim:sts=2:sw=2:ts=8
