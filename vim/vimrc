" vimrc: vim initialization script

" Use vim defaults - not vi
if &compatible
  set nocompatible
endif

" Use vim defaults even if +eval is missing
silent! while 0
set nocompatible
silent! endwhile

" Skip the rest in VSCode
if exists('g:vscode')
  finish
endif

" Always use UTF-8
set encoding=utf-8


"" Disable filetype plugins
" filetype off
"
"" Load plugins with pathogen
" try
"   execute pathogen#infect()
" catch /^Vim(execute):/
" endtry
"
" " Enable filetype plugins & indentation style
" filetype plugin indent on
"
" " Perform syntax highlighting
" if (has("syntax"))
"   syntax enable
" endif


" Load plugins with vim plug
"
call plug#begin(join(split(&runtimepath, ',')[:0] + ['plug'], '/'))
" NOTE: use single quotes around plugin names

Plug 'jlanzarotta/bufexplorer'
Plug 'ctrlpvim/ctrlp.vim'
Plug 'junegunn/fzf.vim'
Plug 'scrooloose/nerdtree'
Plug 'Xuyuanp/nerdtree-git-plugin'
"Plug 'mcchrish/nnn.vim'
Plug 'edkolev/promptline.vim'
Plug 'rust-lang/rust.vim'
Plug 'vim-syntastic/syntastic'
Plug 'majutsushi/tagbar'
Plug 'edkolev/tmuxline.vim'
Plug 'rainglow/vim'
Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'
Plug 'flazz/vim-colorschemes'
Plug 'ryanoasis/vim-devicons'
Plug 'tpope/vim-fugitive'
Plug 'airblade/vim-gitgutter'
Plug 'pangloss/vim-javascript'
Plug 'rodjek/vim-puppet'
Plug 'tpope/vim-repeat'
Plug 'mhinz/vim-startify'
Plug 'tpope/vim-surround'
Plug 'ycm-core/YouCompleteMe'

call plug#end()


" Clear vimrc autocommand group
if has('autocmd')
  augroup vimrc
    autocmd!
  augroup END
endif


" Tabs and Spaces

" Insert spaces insted of tab characters
set expandtab

" Number of columns reserved for line numbers
set numberwidth=3

" Number of spaces to use for an indent
set shiftwidth=2

" Number of spaces to insert for a tab
set softtabstop=2

" Visual width of a tab character (ASCII 0x09)
set tabstop=8

" Length past which lines will be broken automatically
set textwidth=79


" Display and Verbosity

" Display line numbers
set number

" Display line numbers relative to current line
set relativenumber

" Display cursor coordinates (e.g. LINE,COLUMN)
set ruler

" Display most recent command below window
set showcmd

" Briefly jump to match upon completing pair in 'matchpairs'
set showmatch

" Never hide status line
set laststatus=2

" Update terminal titles
set title

" Define terminal titles
let &titlestring = "%t%( [%M%R]%)%( (%{expand(\"%:p:~:h\")})%)%<"

" Show lines that don't fit as @@@ and nonprintable characters as hexadecimal
if v:version >= 800
  set display=truncate,uhex
endif

" Define a function to set 'colorcolumn' to match all columns past 'texwidth'
function UpdateColorColumn()
  if &textwidth
    if &number || &relativenumber
      let l:columns = winwidth(0) - &textwidth - &numberwidth
    else
      let l:columns = winwidth(0) - &textwidth
    endif
    if l:columns > 0
      let &colorcolumn = join(map(range(1, l:columns), '"+" . v:val'), ',')
    else
      let &colorcolumn = ''
    endif
  endif
endfunction

" Set 'colorcolumn' to match all columns past 'textwidth'
call UpdateColorColumn()

" Update 'colorcolumn' upon resizing window

if has('autocmd')
  autocmd vimrc FocusGained,VimEnter,VimResized *
    \ silent! call UpdateColorColumn()
endif

if has('autocmd')
  autocmd vimrc OptionSet *
    \silent! if <amatch> =~ '^\(\(no\)\?relative\)\?\(number\|text\)\(width\)\?$'
    \|  call UpdateColorColumn()
    \|endif
endif


" Window Splitting

" Split windows off toward to right
set splitright

" Split windows off down below
set splitbelow


" Buffer Behavior

" Re-read file if it was changed, unless it was deleted
set autoread

" Hide closed buffers rather than unloading them
set hidden


" Line Wrapping

" Do not wrap lines
"set nowrap

" Break lines before window edge
"set linebreak

" Indent wrapped lines
"set breakindent

" Break lines at these characters
"let &breakat = " \t;:"

" Prefix wrapped lines
"let &showbreak = "> "


" Pattern Matching

" Do not highlight search results
set nohlsearch

" Search forward as pattern is typed
set incsearch

" Ignore case by default
set ignorecase

" Respect case if pattern contains uppercase
set smartcase

" Additional bases recognized for increment/decrement
set nrformats=bin,hex


" Cursor Position

" Attempt to preserve cursor position when moving linewise
set nostartofline

" Allow backspacing over everything in insert mode
set backspace=indent,eol,start

" Lines of padding between cursor and edge of window
set scrolloff=3

" If 'nowrap' is set, minimum number of columnss to scroll at a time
set sidescroll=1

" If 'nowrap' is set, columns of padding between cursor and edge of window
set sidescrolloff=3

" Allow visual-block selection of empty columns
set virtualedit=block


" Completion

" Tweak insert-mode completion
set completeopt=menu,preview,noselect

" Enable command completion
set wildmenu

" Ignore case for filename completion
set wildignorecase

" Tweak command-mode completion
set wildmode=longest:full,full

" Use <Left> and <Right> to move cursor rather than selecting completions
cnoremap <Left>  <C-]><Left>
cnoremap <Right> <C-]><Right>


" Key Timeout

" Timeout on mappings and keycodes
set timeout

" milliseconds to wait for completion of a mapping
set timeoutlen=1000

" milliseconds to wait for completion of a key code
set ttimeoutlen=80

if has('nvim')
  set nottimeout
endif


" History

" Number of search patterns and ``:'' commands to remember (max: 10000)
set history=10000

" Number of modifications to remember for a given file
set undolevels=2500

" Always save entire buffer for undo when reloading it
set undoreload=-1

" Max characters typed between swapfile syncs
set updatecount=40

" Max milliseconds elapsed between swapfile syncs (also used by gitgutter)
set updatetime=200


" Tags File Locations
set tags=
set tags+=./tags
set tags+=./.tags
set tags+=tags
set tags+=.tags

" Swapfile and Undofile

" Check undofile capability and use if using swapfile
if has('persistent_undo')
  let &undofile = &swapfile
endif

" Clear swap / undo directory preferences
set directory=
set   undodir=

" Append XDG_DATA_HOME if non-null
if $XDG_DATA_HOME != ''
  set directory+=$XDG_DATA_HOME/vim/swap/
  set   undodir+=$XDG_DATA_HOME/vim/undo/
endif

" Append XDG_CACHE_HOME if non-null
if $XDG_CACHE_HOME != ''
  set directory+=$XDG_CACHE_HOME/vim/swap/
  set   undodir+=$XDG_CACHE_HOME/vim/undo/
endif

" Append first element of 'runtimepath'
if !empty(split(&runtimepath, ','))
  if &directory == ''
    let &directory = split(&runtimepath, ',')[0] . '/swap/'
  else
    let &directory .= ',' . split(&runtimepath, ',')[0] . '/swap/'
  endif
  if (&undodir == '')
    let &undodir = split(&runtimepath, ',')[0] . '/undo/'
  else
    let &undodir .= ',' . split(&runtimepath, ',')[0] . '/undo/'
  endif
endif

" Append default tmp directories
set directory+=/var/tmp/,/tmp/
set   undodir+=/var/tmp/,/tmp/

" Create the primary swap directory
if !isdirectory(split(&directory, ',')[0])
  silent! call mkdir(split(&directory, ',')[0], 'p', 0700)
endif

" Create the primary undo directory
if !isdirectory(split(&undodir, ',')[0])
  silent! call mkdir(split(&undodir, ',')[0], 'p', 0700)
endif


" Terminal

" F**k terminal bells
set belloff=all


" Mouse

" Enable the mouse
if has('mouse')
  set mouse=a
  if has('mouse_sgr') && !has('nvim')
    set ttymouse=sgr
  endif
endif


" Mappings

" Set a key to act as <leader> in mappings
let g:mapleader = ','


" Colors

" Set 'colors' cap
if $COLORTERM =~? '^truecolor$'
  let &t_Co = 16777216
elseif $COLORTERM =~ '^rxvt-xpm$' || $TERM =~ '^.*-256color\%(-.*\)\?$'
  let &t_Co = 256
endif

" Try to guess color capabilities
if exists('+termguicolors')
  if $TERM =~ '^\%(rxvt\|screen\|interix\|putty\)\%(-.*\)\?$'
      set notermguicolors
  elseif $TERM =~ '^\%(alacritty\|iterm\|vte\|gnome\|st\)\%(-.*\)\?$'
    if !has('nvim')
      let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
      let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
    endif
    set termguicolors
  elseif $TERM =~ '^\%(tmux\|xterm\)\%(-.*\)\?$'
    if $XTERM_VERSION != '' || $VTE_VERSION != '' || $KONSOLE_PROFILE_NAME != ''
      if !has('nvim')
        let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
        let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
      endif
      set termguicolors
    else
      set notermguicolors
    endif
  else
    set notermguicolors
  endif
endif


" Choose some colors
let g:colorschemes = []
if &t_Co > 16
  if &termguicolors
    let g:colorschemes += [
      \ 'neonwave',
      \ 'nightshimmer',
      \ '3dglasses',
      \ 'grunge-contrast',
      \ 'grunge',
      \ 'candycode',
      \ 'afterglow',
      \ 'kiss',
      \ 'neverland2-darker',
      \ 'neverland2',
      \ 'candy',
      \ 'fruity',
      \ 'darkZ',
      \ ]
  endif
  let g:colorschemes += [
    \ 'Tomorrow-Night-Eighties',
    \ 'skittles_berry',
    \ 'squidink',
    \ 'desertink',
    \ '1989',
    \ 'dracula',
    \ 'vice',
    \ 'evolution',
    \ 'Benokai',
    \ 'lucius',
    \ ]
else
  let g:colorschemes += [
    \ 'evening',
    \ 'desert',
    \ 'default'
    \ ]
endif

execute join(['colorscheme', g:colorschemes[0]])

" Define a function to rotate the colorscheme
function RotateColorscheme(n)
  if exists('g:colorschemes')
    try
      let l:index = max([index(g:colorschemes, g:colors_name), 0])
    catch /^Vim(let)\=:E121/
      let l:index = 0
    endtry
    let l:shift = 0
    let l:limit = len(g:colorschemes)
    while l:shift < l:limit
      let l:index = (l:index + a:n) % l:limit
      try
        execute 'colorscheme' g:colorschemes[l:index]
        break
      catch /^Vim(colorscheme):/
      endtry
      let l:shift += 1
    endwhile
  endif
endfunction

" F8: Rotate to prev colorscheme
nnoremap <silent> <F8> :
  \
  \silent! call RotateColorscheme(-1)<CR>

" F9: Rotate to next colorscheme
nnoremap <silent> <F9> :
  \
  \silent! call RotateColorscheme(1)<CR>


" C / C++
" Recognize strings & numbers inside comments
let g:c_comment_strings = 1

" Highlight GNU specific items
let g:c_gnu = 1

" Highlight space errors
let g:c_space_errors = 1

" Set local options for C and C++ files
if has('autocmd')
  autocmd vimrc FileType c,cpp
        \ silent! setlocal cin cino=:0,(8 noet sts=0 sw=8 ts=8
endif


" Gitcommit

" Set textwidth for commit messages
if has('autocmd')
  autocmd vimrc FileType gitcommit
    \ silent! setlocal tw=50
endif


" Markdown

" Set local options for markdown documents (e.g. README, etc.)
if has('autocmd')
  if has('linebreak')
    autocmd vimrc FileType markdown
      \ silent! setlocal nonu nornu wrap lbr bri
  else
    autocmd vimrc FileType markdown
      \ silent! setlocal nonu nornu wrap
  endif
endif


" Man pages

" Load the Man plugin
runtime ftplugin/man.vim

" Use K to open man pages
set keywordprg=:Man

" Set local options for man pages
if has('autocmd')
  autocmd vimrc FileType man
    \ silent! setlocal nohid noma nonu nornu noswf noudf tw=0
endif


" Python

" Set local options for python scripts
if has('autocmd')
  autocmd vimrc FileType python
    \ silent! setlocal et sts=4 sw=4 ts=8 tw=79
endif

" Enable all available highlighting
let g:python_highlight_all = 1

" Enable syntastic plugins
let g:syntastic_python_checkers = ['pycodestyle', 'pylint', 'python']

" Set the default version for pyx commands
if has('pythonx')
  if has('python3')
    set pyxversion=3
  elseif has('python2')
    set pyxversion=2
  endif
endif


" Readline

" Highlight bash additions
let g:readline_has_bash = 1


" Sed

" Highlight real tabs in sed scripts
let g:highlight_sedtabs = 1


" Sh

" Default highlighting for shell scripts
let g:is_posix = 1

" Fold functions and if/do/for clauses
let g:sh_fold_enabled = 3

" Relax error detection
let g:sh_no_error = 1

" Set local options when opening a shell script
if has("autocmd")
  autocmd vimrc FileType bash,ksh,sh,zsh
    \ silent! setlocal et sts=2 sw=2 ts=8
endif

" Set filetype to sh when editing a shell command line
if has("autocmd")
  autocmd vimrc BufRead bash-fc.*
    \ silent! setlocal et ft=sh noswf noudf
    \|silent! let b:is_bash = 1
    \|silent! syntax enable
endif


" help

" Set local options when opening vim help
if has("autocmd")
  autocmd vimrc FileType help
    \ silent! setlocal noswf noudf
endif


" Completion

set complete=
set complete+=.
set complete+=w
set complete+=b
set complete+=u
set complete+=d
set complete+=t

set completeopt=
set completeopt+=preview
set completeopt+=noselect
set completeopt+=menuone

" omnifunc fallback
if has("autocmd") && exists("+omnifunc")
  autocmd vimrc Filetype *
    \ silent! if &omnifunc == ''
    \|  silent! setlocal omnifunc=syntaxcomplete#Complete
    \|silent! endif
endif


" Airline

let g:airline_powerline_fonts = 1
let g:airline_left_sep = "\UE0C0"
let g:airline_right_sep = "\UE0C2"
let g:airline_left_alt_sep = "\UE0B1"
let g:airline_right_alt_sep = "\UE0B3"

if !(exists('g:airline_symbols'))
  let g:airline_symbols = {}
endif
let g:airline_symbols.branch      = ''
let g:airline_symbols.crypt       = ''
let g:airline_symbols.dirty       = '  '
let g:airline_symbols.ellipsis    = '…'
let g:airline_symbols.linenr      = '﬌'
let g:airline_symbols.maxlinenr   = ''
let g:airline_symbols.notexists   = ' Ɇ '
let g:airline_symbols.modified    = '  '
let g:airline_symbols.readonly    = ''
let g:airline_symbols.paste       = ''
let g:airline_symbols.space       = ' '
let g:airline_symbols.whitespace  = ''
"let g:airline_symbols.readonly   = ''
"let g:airline_symbols.dirty      = ''
"let g:airline_symbols.crypt      = ''
"let g:airline_symbols.linenr     = ''
"let g:airline_symbols.maxlinenr  = ''
"let g:airline_symbols.notexists  = ''
"let g:airline_symbols.spell      = ''
"let g:airline_symbols.whitespace = ''

let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#tabline#formatter = "unique_tail_improved"
let g:airline#extensions#tabline#overflow_marker = '…'
let g:airline#extensions#tabline#buffer_nr_show = 1
let g:airline#extensions#tabline#fnamecollapse = 1

"let g:airline#extensions#tagbar#enabled = 1

"let g:airline#extensions#ycm#enabled = 1

" Put some Airline themes in a list
let g:airline_themes = [
    \ 'owo',
    \ 'base16_ashes',
    \ 'biogoo',
    \ 'atomic',
    \ 'tomorrow',
    \ 'behelit',
    \ 'kolor',
    \ 'night_owl',
    \ 'base16_eighties',
    \ 'base16_snazzy',
    \ 'base16color',
    \ ]

" Set an Airline theme
let g:airline_theme = g:airline_themes[0]

" Define a function to rotate the Airline theme
function RotateAirlineTheme(n)
  if exists('g:airline_themes')
    try
      let l:index = max([index(g:airline_themes, g:airline_theme), 0])
    catch /^Vim(let)\=:E121/
      let l:index = 0
    endtry
    let l:shift = 0
    let l:limit = len(g:airline_themes)
    while l:shift < l:limit
      let l:index = (l:index + a:n) % l:limit
      try
        execute 'AirlineTheme' g:airline_themes[l:index]
        break
      catch /^Vim(AirlineTheme):/
      endtry
      let l:shift += 1
    endwhile
  endif
endfunction

" Alt F8: Rotate to prev airline theme
nnoremap <silent> <Esc><F8> :
  \
  \silent! call RotateAirlineTheme(-1)<CR>

" Alt F9: Rotate to next airline theme
nnoremap <silent> <Esc><F9> :
  \
  \silent! call RotateAirlineTheme(1)<CR>

" Refresh airline when the colorscheme changes
if has('autocmd')
  autocmd vimrc ColorScheme *
    \
    \silent! AirlineRefresh
endif


" CtrlP

let g:ctrlp_map = '<C-]>'


" DevIcons
let g:webdevicons_enable = 1
let g:webdevicons_enable_nerdtree = 1
let g:webdevicons_enable_airline_tabline = 1
let g:webdevicons_enable_airline_statusline = 1
let g:webdevicons_enable_startify = 1
let g:webdevicons_gui_glyph_fix = 1
let g:webdevicons_conceal_nerdtree_brackets = 1
let g:WebDevIconsUnicodeDecorateFolderNodes = 1
let g:DevIconsEnableFoldersOpenClose = 1
let g:WebDevIconsNerdTreeGitPluginForceVAlign = 1


" FZF
let g:fzf_colors = {
  \   'fg':       ['fg', 'Normal'],
  \   'bg':       ['bg', 'Normal'],
  \   'hl':       ['fg', 'Comment'],
  \   'fg+':      ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
  \   'bg+':      ['bg', 'CursorLine', 'CursorColumn'],
  \   'hl+':      ['fg', 'Statement'],
  \   'info':     ['fg', 'PreProc'],
  \   'border':   ['fg', 'Ignore'],
  \   'prompt':   ['fg', 'Conditional'],
  \   'pointer':  ['fg', 'Exception'],
  \   'marker':   ['fg', 'Keyword'],
  \   'spinner':  ['fg', 'Label'],
  \   'header':   ['fg', 'Comment'],
  \ }

let g:fzf_buffers_jump = 1
let g:fzf_tags_command = 'ctags -f .tags -R'
let g:fzf_commands_expect = 'alt-enter'

nnoremap <silent> <leader><F12> :
  \
  \call fzf#run({
  \ 'source': map(
  \   split(globpath(&rtp, "colors/*.vim"), "\n"),
  \   "substitute(fnamemodify(v:val, ':t'), '\\..\\{-}$', '', '')"
  \ ),
  \ 'sink': 'colo',
  \ 'options': '+m',
  \ 'left': 30
  \})
  \<CR>


" NERDTree
let g:NERDTreeIndicatorMapCustom = {
    \   'Modified'  : '',
    \   'Staged'    : '',
    \   'Untracked' : '',
    \   'Renamed'   : '',
    \   'Unmerged'  : '',
    \   'Deleted'   : 'Ɇ',
    \   'Dirty'     : '',
    \   'Clean'     : '',
    \   'Ignored'   : '',
    \   'Unknown'   : '',
    \ }

" Disable arrow icons at the left side of folder icons
let g:NERDTreeDirArrowExpandable  = "\U202F"
let g:NERDTreeDirArrowCollapsible = "\U202F"


" Syntastic

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 0
let g:syntastic_check_on_open = 0
let g:syntastic_check_on_wq = 0
let g:pymode_lint_on_write = 0


" YouCompleteMe

let g:ycm_max_num_candidates = 40
let g:ycm_collect_identifiers_from_tags_files = 1
let g:ycm_autoclose_preview_window_after_completion = 1
let g:ycm_key_list_stop_completion = ['<C-]>']

if has('autocmd')
  autocmd vimrc FileType *
    \ let b:ycm_hover = {
    \ 'command': 'GetDoc',
    \ 'syntax': &syntax
    \ }
endif

nmap <leader>D <plug>(YCMHover)


" Tabs

" Next tab
nnoremap <silent> <M-Right> :
  \
  \tabnext<CR>

" Previous tab
nnoremap <silent> <M-Left> :
  \
  \tabprev<CR>

" Create tab
nnoremap <silent> <leader>c :
  \
  \tabnew<CR>

" Destroy tab
nnoremap <silent> <leader>x :
  \
  \tabprev<CR>

" Insert: Toggle 'paste' mode
nnoremap <silent> <Insert> :
  \
  \set paste!<CR>

set pastetoggle=<Insert>


" F6: Toggle line numbers
nnoremap <silent> <F6> :
  \
  \let &l:nu = !&l:nu<Bar>
  \let &l:rnu = &l:nu<CR>

" F7: Toggle search highlighting
nnoremap <silent> <F7> :
  \
  \setlocal hlsearch!<CR>

" Insert a shebang as the first line
nnoremap <silent> <leader>#! ggI<C-R>=
  \
  \substitute(&filetype, "..*", "#!" . exepath(&filetype) . "\\r", "")<CR>
  \<ESC>``

" Search forward for the current visual selection
" Note: Jumping to a tag does not set the current search pattern
vnoremap <silent> * :
  \
  \<C-U>let old_reg=getreg('"')<Bar>
  \let old_regtype=getregtype('"')<CR>
  \gvy/<C-R><C-R>=
  \substitute(escape(@",'/\.*$^~['),'\_s\+','\\_s\\+','g')<CR><CR>
  \gV:call setreg('"',old_reg,old_regtype)<CR>

" Search backward for the current visual selection
" Note: Jumping to a tag does not set the current search pattern
vnoremap <silent> # :
  \
  \<C-U>let old_reg=getreg('"')<Bar>
  \let old_regtype=getregtype('"')<CR>
  \gvy?<C-R><C-R>=
  \substitute(escape(@",'?\.*$^~['),'\_s\+','\\_s\\+','g')<CR><CR>
  \gV:call setreg('"',old_reg,old_regtype)<CR>


" Fix escape sequences in vim
if !has('nvim')

  " Map xterm sequences for <S-Arrow> combinations
  map! <ESC>[1;2A <S-Up>
  map! <ESC>[1;2B <S-Down>
  map! <ESC>[1;2C <S-Right>
  map! <ESC>[1;2D <S-Left>
  nmap <ESC>[1;2A <S-Up>
  nmap <ESC>[1;2B <S-Down>
  nmap <ESC>[1;2C <S-Right>
  nmap <ESC>[1;2D <S-Left>
  vmap <ESC>[1;2A <S-Up>
  vmap <ESC>[1;2B <S-Down>
  vmap <ESC>[1;2C <S-Right>
  vmap <ESC>[1;2D <S-Left>

  " Map xterm sequences for <M-Arrow> combinations
  map! <ESC>[1;3A <M-Up>
  map! <ESC>[1;3B <M-Down>
  map! <ESC>[1;3C <M-Right>
  map! <ESC>[1;3D <M-Left>
  nmap <ESC>[1;3A <M-Up>
  nmap <ESC>[1;3B <M-Down>
  nmap <ESC>[1;3C <M-Right>
  nmap <ESC>[1;3D <M-Left>
  vmap <ESC>[1;3A <M-Up>
  vmap <ESC>[1;3B <M-Down>
  vmap <ESC>[1;3C <M-Right>
  vmap <ESC>[1;3D <M-Left>

  " Map xterm sequences for <M-S-Arrow> combinations
  map! <ESC>[1;4A <M-S-Up>
  map! <ESC>[1;4B <M-S-Down>
  map! <ESC>[1;4C <M-S-Right>
  map! <ESC>[1;4D <M-S-Left>
  nmap <ESC>[1;4A <M-S-Up>
  nmap <ESC>[1;4B <M-S-Down>
  nmap <ESC>[1;4C <M-S-Right>
  nmap <ESC>[1;4D <M-S-Left>
  vmap <ESC>[1;4A <M-S-Up>
  vmap <ESC>[1;4B <M-S-Down>
  vmap <ESC>[1;4C <M-S-Right>
  vmap <ESC>[1;4D <M-S-Left>

  " Map xterm sequences for <C-Arrow> combinations
  map! <ESC>[1;5A <C-Up>
  map! <ESC>[1;5B <C-Down>
  map! <ESC>[1;5C <C-Right>
  map! <ESC>[1;5D <C-Left>
  nmap <ESC>[1;5A <C-Up>
  nmap <ESC>[1;5B <C-Down>
  nmap <ESC>[1;5C <C-Right>
  nmap <ESC>[1;5D <C-Left>
  vmap <ESC>[1;5A <C-Up>
  vmap <ESC>[1;5B <C-Down>
  vmap <ESC>[1;5C <C-Right>
  vmap <ESC>[1;5D <C-Left>

  " Map xterm sequences for <C-S-Arrow> combinations
  map! <ESC>[1;6A <C-S-Up>
  map! <ESC>[1;6B <C-S-Down>
  map! <ESC>[1;6C <C-S-Right>
  map! <ESC>[1;6D <C-S-Left>
  nmap <ESC>[1;6A <C-S-Up>
  nmap <ESC>[1;6B <C-S-Down>
  nmap <ESC>[1;6C <C-S-Right>
  nmap <ESC>[1;6D <C-S-Left>
  vmap <ESC>[1;6A <C-S-Up>
  vmap <ESC>[1;6B <C-S-Down>
  vmap <ESC>[1;6C <C-S-Right>
  vmap <ESC>[1;6D <C-S-Left>

  " Map xterm sequences for <C-M-Arrow> combinations
  map! <ESC>[1;7A <C-M-Up>
  map! <ESC>[1;7B <C-M-Down>
  map! <ESC>[1;7C <C-M-Right>
  map! <ESC>[1;7D <C-M-Left>
  nmap <ESC>[1;7A <C-M-Up>
  nmap <ESC>[1;7B <C-M-Down>
  nmap <ESC>[1;7C <C-M-Right>
  nmap <ESC>[1;7D <C-M-Left>
  vmap <ESC>[1;7A <C-M-Up>
  vmap <ESC>[1;7B <C-M-Down>
  vmap <ESC>[1;7C <C-M-Right>
  vmap <ESC>[1;7D <C-M-Left>

  " Map xterm sequences for <C-M-S-Arrow> combinations
  map! <ESC>[1;8A <C-M-S-Up>
  map! <ESC>[1;8B <C-M-S-Down>
  map! <ESC>[1;8C <C-M-S-Right>
  map! <ESC>[1;8D <C-M-S-Left>
  nmap <ESC>[1;8A <C-M-S-Up>
  nmap <ESC>[1;8B <C-M-S-Down>
  nmap <ESC>[1;8C <C-M-S-Right>
  nmap <ESC>[1;8D <C-M-S-Left>
  vmap <ESC>[1;8A <C-M-S-Up>
  vmap <ESC>[1;8B <C-M-S-Down>
  vmap <ESC>[1;8C <C-M-S-Right>
  vmap <ESC>[1;8D <C-M-S-Left>

  " Map xterm and rxvt escape sequences for <Fn> keys
  map! <ESC>OP   <F1>
  map! <ESC>OQ   <F2>
  map! <ESC>OR   <F3>
  map! <ESC>OS   <F4>
  map! <ESC>[11~ <F1>
  map! <ESC>[12~ <F2>
  map! <ESC>[13~ <F3>
  map! <ESC>[14~ <F4>
  map! <ESC>[15~ <F5>
  map! <ESC>[17~ <F6>
  map! <ESC>[18~ <F7>
  map! <ESC>[19~ <F8>
  map! <ESC>[20~ <F9>
  map! <ESC>[21~ <F10>
  map! <ESC>[23~ <F11>
  map! <ESC>[24~ <F12>
  nmap <ESC>OP   <F1>
  nmap <ESC>OQ   <F2>
  nmap <ESC>OR   <F3>
  nmap <ESC>OS   <F4>
  nmap <ESC>[11~ <F1>
  nmap <ESC>[12~ <F2>
  nmap <ESC>[13~ <F3>
  nmap <ESC>[14~ <F4>
  nmap <ESC>[15~ <F5>
  nmap <ESC>[17~ <F6>
  nmap <ESC>[18~ <F7>
  nmap <ESC>[19~ <F8>
  nmap <ESC>[20~ <F9>
  nmap <ESC>[21~ <F10>
  nmap <ESC>[23~ <F11>
  nmap <ESC>[24~ <F12>
  vmap <ESC>OP   <F1>
  vmap <ESC>OQ   <F2>
  vmap <ESC>OR   <F3>
  vmap <ESC>OS   <F4>
  vmap <ESC>[11~ <F1>
  vmap <ESC>[12~ <F2>
  vmap <ESC>[13~ <F3>
  vmap <ESC>[14~ <F4>
  vmap <ESC>[15~ <F5>
  vmap <ESC>[17~ <F6>
  vmap <ESC>[18~ <F7>
  vmap <ESC>[19~ <F8>
  vmap <ESC>[20~ <F9>
  vmap <ESC>[21~ <F10>
  vmap <ESC>[23~ <F11>
  vmap <ESC>[24~ <F12>

  " Map xterm and rxvt escape sequences for <S-Fn> combinations
  map! <ESC>[23~   <S-F1>
  map! <ESC>[24~   <S-F2>
  map! <ESC>[1;2P  <S-F3>
  map! <ESC>[1;2Q  <S-F4>
  map! <ESC>[1;2R  <S-F5>
  map! <ESC>[1;2S  <S-F6>
  map! <ESC>[15;2~ <S-F7>
  map! <ESC>[17;2~ <S-F8>
  map! <ESC>[18;2~ <S-F9>
  map! <ESC>[19;2~ <S-F10>
  map! <ESC>[23;2~ <S-F11>
  map! <ESC>[24;2~ <S-F12>
  map! <ESC>[25~   <S-F3>
  map! <ESC>[26~   <S-F4>
  map! <ESC>[28~   <S-F5>
  map! <ESC>[29~   <S-F6>
  map! <ESC>[31~   <S-F7>
  map! <ESC>[32~   <S-F8>
  map! <ESC>[33~   <S-F9>
  map! <ESC>[34~   <S-F10>
  map! <ESC>[23$   <S-F11>
  map! <ESC>[24$   <S-F12>
  nmap <ESC>[23~   <S-F1>
  nmap <ESC>[24~   <S-F2>
  nmap <ESC>[1;2P  <S-F3>
  nmap <ESC>[1;2Q  <S-F4>
  nmap <ESC>[1;2R  <S-F5>
  nmap <ESC>[1;2S  <S-F6>
  nmap <ESC>[15;2~ <S-F7>
  nmap <ESC>[17;2~ <S-F8>
  nmap <ESC>[18;2~ <S-F9>
  nmap <ESC>[19;2~ <S-F10>
  nmap <ESC>[23;2~ <S-F11>
  nmap <ESC>[24;2~ <S-F12>
  nmap <ESC>[25~   <S-F3>
  nmap <ESC>[26~   <S-F4>
  nmap <ESC>[28~   <S-F5>
  nmap <ESC>[29~   <S-F6>
  nmap <ESC>[31~   <S-F7>
  nmap <ESC>[32~   <S-F8>
  nmap <ESC>[33~   <S-F9>
  nmap <ESC>[34~   <S-F10>
  nmap <ESC>[23$   <S-F11>
  nmap <ESC>[24$   <S-F12>
  vmap <ESC>[23~   <S-F1>
  vmap <ESC>[24~   <S-F2>
  vmap <ESC>[1;2P  <S-F3>
  vmap <ESC>[1;2Q  <S-F4>
  vmap <ESC>[1;2R  <S-F5>
  vmap <ESC>[1;2S  <S-F6>
  vmap <ESC>[15;2~ <S-F7>
  vmap <ESC>[17;2~ <S-F8>
  vmap <ESC>[18;2~ <S-F9>
  vmap <ESC>[19;2~ <S-F10>
  vmap <ESC>[23;2~ <S-F11>
  vmap <ESC>[24;2~ <S-F12>
  vmap <ESC>[25~   <S-F3>
  vmap <ESC>[26~   <S-F4>
  vmap <ESC>[28~   <S-F5>
  vmap <ESC>[29~   <S-F6>
  vmap <ESC>[31~   <S-F7>
  vmap <ESC>[32~   <S-F8>
  vmap <ESC>[33~   <S-F9>
  vmap <ESC>[34~   <S-F10>
  vmap <ESC>[23$   <S-F11>
  vmap <ESC>[24$   <S-F12>

endif


" End

" Allow options to be set from a modeline
set modeline

" Restrict editor if SWIM owns this file (should be last in vimrc)
set secure


" vi:et:ft=vim:sts=2:sw=2:ts=8
