#
## ~/.bashrc : initialization file for interactive shells
#

## Is this an interactive shell? If not, stop.
[[ $- != *i* ]] && return

## If DISPLAY is non-null, sync LINES and COLUMNS after each command
[[ -n ${DISPLAY}  ]] && shopt -s checkwinsize


## Set GPG_TTY to the current tty (if there is one)
export GPG_TTY=$(\command -p tty 2>/dev/null)

## Refresh gpg-agent in case user switched to an Xsession
\command -p gpg-connect-agent updatestartuptty /bye 1>/dev/null 2>&1 


## Functions, cmd substitutions, and subshells inherit traps on 'ERR' 
set -o errtrace

## Require the >| operator to overwrite existing files by redirection
set -o noclobber


## If the name of a directory is given as a command, pass it to cd
shopt -s autocd

## Check that a command found in the hashtable exists before running it
shopt -s checkhash

## Show jobs before exiting and require confirmation if any are running
shopt -s checkjobs

## Attempt to save each multiline command as a single history entry
shopt -s cmdhist

## Expand the name of a directory upon performing filename completion
shopt -s direxpand

## Attempt to correct mispelled directory names during word completion
shopt -s dirspell

## Enable extended pattern matching features
shopt -s extglob

## Range expressions used in bracket expressions behave as in the C locale 
shopt -s globasciiranges

## Let ``**`` match all files and 0 or more directories and subdirectories
shopt -s globstar

## Send SIGHUP(1) to all jobs when an interactive login shell exits
shopt -s huponexit

## Append to the history file instead of overwriting it
shopt -s histappend

## If using rl, allow user to re-edit a failed history substitution
shopt -s histreedit

## If using rl, load history substitutions into the editing buffer
shopt -s histverify

## Command substitutions inherit the value of the 'errexit' option
shopt -s inherit_errexit

## If job control is off, run the last cmd of a pipeline in the current shell
shopt -s lastpipe

## With 'cmdhist' enabled, save multiline commands with embedded newlines
shopt -s lithist


## Set EXECIGNORE to match shared object libraries
EXECIGNORE='?(?(+(/)usr)+(/))lib?(32|64))+(/)**/*.@(so*(.+( , ,[[:digit:]]))|dll)'

## Set GLOBIGNORE to match instances of ``.`` and ``..``
GLOBIGNORE='*(?(.)?(.|*)/).?(.)*(/)'

## Setting GLOBIGNORE enables 'dotglob' so disable it for 
shopt -u dotglob



## Configure the location of the history file
\command -p mkdir -p -m 700 "${XDG_DATA_HOME:-"${HOME}/.local/share"}/bash" \
  && HISTFILE="${XDG_DATA_HOME:-"${HOME}/.local/share"}/bash/history" \
  || HISTFILE="${HOME}/.bash_history"

## Set max number of entries to store on disk
HISTFILESIZE=10000

## Set max number of entries to store in memory
HISTSIZE=-1

## Erase duplicate entries from the history
HISTCONTROL='erasedups'

## If 'extglob' is on, ignore dups regardless of surrounding whitespace
HISTIGNORE='*([[:blank:]])&*([[:blank:]])'


## Create an array to store terminal info
declare -A ti=( )

## Limit depth of paths generated by '\w' during prompt expansion
declare -i PROMPT_DIRTRIM=4

## Initialize LINES and COLUMNS
declare -i LINES="$(tput lines)"
declare -i COLUMNS="$(tput cols)"


## Define function to set the primary prompt
function PS1() {
  PS1=\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
'\['"${ti['bold']:="$(tput bold)"}"'\]'\
'\['"${ti['dim']:="$(tput dim)"}"'\]'\
'\['"$1"'\]'\
'$(tput dl1
  printf '"'"'%.s—'"'"' {1..'"$((COLUMNS?(COLUMNS):"$(tput cols)"))"'})'\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
'\n'\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
'\['"${ti['bold']:="$(tput bold)"}"'\]'\
'\u'\
'\['"${ti['dim']:="$(tput dim)"}"'\]'\
'@'\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
'\['"${ti['bold']:="$(tput bold)"}"'\]'\
'\h'\
'\['"${ti['dim']:="$(tput dim)"}"'\]'\
':'\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
'\['"${ti['bold']:="$(tput bold)"}"'\]'\
'\w'\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
'\n'\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
'\['"${ti['bold']:="$(tput bold)"}"'\]'\
'\D{%A %d %B %Y %I:%M %p}'\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
'\n'\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
'\['"${ti['bold']:="$(tput bold)"}"'\]'\
'\['"${ti['dim']:="$(tput dim)"}"'\]'\
'\['"$1"'\]'\
'\$λ'\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
' '
}


## Define function to set the secondary prompt
function PS2() {
  PS2=\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
'\['"${ti['bold']:="$(tput bold)"}"'\]'\
'\['"${ti['dim']:="$(tput dim)"}"'\]'\
'\['"$1"'\]'\
'$(( (LINENO - '"$(( BASH_LINENO[-1] ))"') / 10 ))'\
'$(( (LINENO - '"$(( BASH_LINENO[-1] ))"') % 10 ))'\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
' '
}


## Define function to set the select prompt
function PS3() {
   PS3="${PS3:-"•◆ "}"
}


## Define function to set the execution-trace prompt
function PS4() {
  PS4=\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
'\['"${ti['bold']:="$(tput bold)"}"'\]'\
'\['"${ti['dim']:="$(tput dim)"}"'\]'\
'•'\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
'\['"${ti['bold']:="$(tput bold)"}"'\]'\
'◆'\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
' '
}


## Define function to set the prompts (must be first cmd of PROMPT_COMMAND)
function setPS() {
  set -- "$(tput setaf "$(( $? ? ($? - 1) % 6 + 1 : 7 ))")"
  PS1 "$1"
  PS2 "$1"
  PS3 "$1"
  PS4 "$1"
}


## Update prompt strings before printing the primary prompt
PROMPT_COMMAND='setPS'

## Set terminal window titles
case ${TERM} in
  xterm*|rxvt*|urxvt*|Eterm|aterm|kterm|gnome*)
    PROMPT_COMMAND+=${PROMPT_COMMAND:+; }\
'printf "\033]0;%s@%s:%s\007" "${USER}" "${HOSTNAME%%.*}" "${PWD/#${HOME}/\~}"'
    ;;
  screen*|tmux*)
    PROMPT_COMMAND+=${PROMPT_COMMAND:+; }\
'printf "\033_%s@%s:%s\033\\" "${USER}" "${HOSTNAME%%.*}" "${PWD/#${HOME}/\~}"'
    ;;
esac


## Load any additional config in ~/.bashrc.d
[[ -d ~/.bashrc.d ]] &&
  for _ in ~/.bashrc.d/*; do
    [[ -f $_ ]] && . "$_"
  done
