## ~/.bashrc : bash config for interactive shells
## Patrick DeYoreo

## This file is sourced by all *interactive* bash shells on startup,
## including some apparently interactive shells such as scp and rcp
## that can't tolerate any output. So make sure this doesn't display
## anything or bad things will happen !

## Test for an interactive shell.  There is no need to set anything
## past this point for scp and rcp, and it's important to refrain from
## outputting anything in those cases.
[[ $- != *i* ]] && return

## If DISPLAY is set check LINES and COLUMNS after each command
[[ ${DISPLAY} ]] && shopt -s checkwinsize

## Require '>|' to overwrite files & set the return value of a pipeline
## to the exit status of the last command to fail
set -o noclobber

## Enable nonstandard shell options
shopt -s                                                          \
  autocd        cdable_vars   cdspell     checkhash   checkjobs   \
  cmdhist       dirspell      extglob     globstar    histappend  \
  histreedit    histverify    huponexit   lastpipe    lithist

## Configure command history
HISTFILE="${HOME}/.shell_history"
HISTFILESIZE=30000
HISTSIZE=30000
HISTCONTROL='ignoredups:erasedups'
HISTIGNORE='*([[\:blank\:]])\:*([[\:blank\:]]);*'

## Ignore current (.) and parent (..) when globbing
GLOBIGNORE='?(*/).?(.)'

## Limit depth of paths generated by '\w' upon prompt expansion
PROMPT_DIRTRIM=4

## Build array of escape sequences for video attributes
declare -A sgr=(
  [C]=$(tput sgr 0 0 0 0 0 0 0 0 1) # altCharset
  [P]=$(tput sgr 0 0 0 0 0 0 0 1 0) # Protect
  [I]=$(tput sgr 0 0 0 0 0 0 1 0 0) # Invis
  [B]=$(tput sgr 0 0 0 0 0 1 0 0 0) # Bold
  [D]=$(tput sgr 0 0 0 0 1 0 0 0 0) # Dim
  [L]=$(tput sgr 0 0 0 1 0 0 0 0 0) # bLink
  [R]=$(tput sgr 0 0 1 0 0 0 0 0 0) # Reverse
  [U]=$(tput sgr 0 1 0 0 0 0 0 0 0) # Underline
  [S]=$(tput sgr 1 0 0 0 0 0 0 0 0) # Standout
  [N]=$(tput sgr 0 0 0 0 0 0 0 0 0) # Normal
  [0]=$(tput sgr0)                  # off
)

## Build array of escape sequences for foreground colors
eval eval "'"'declare -a setaf=( $('"'"' '"'"'tput setaf '"'"\
'{0..'"$(("$(tput colors)" - 1))"'}'\
"'"'; printf '"'"'"'"'"'"'"'\n'"'"'"'"'"'"'"';'"'"' '"'"') )'"'"

## Build array of escape sequences for background colors
eval eval "'"'declare -a setab=( $('"'"' '"'"'tput setab '"'"\
'{0..'"$(("$(tput colors)" - 1))"'}'\
"'"'; printf '"'"'"'"'"'"'"'\n'"'"'"'"'"'"'"';'"'"' '"'"') )'"'"


## Define function to set the primary prompt
PS1() {
  PS1="${PS0}"'\
\['"${sgr[N]}${sgr[B]}"'\]\u\['"${sgr[D]}"'\]@\
\['"${sgr[N]}${sgr[B]}"'\]\h\['"${sgr[D]}"'\]:\
\['"${sgr[N]}${sgr[B]}"'\]\w\['"${sgr[N]}"'\]\n\
\['"${sgr[N]}${sgr[B]}"'\]\D{%A %B %d %Y}\['"${sgr[N]}"'\]\n\
\['"${sgr[N]}${sgr[B]}"'\]\D{%I:%M %p %Z}\['"${sgr[N]}"'\]\n\
\['"${sgr[N]}${sgr[B]}"'\]\$λ\['"${sgr[N]}"'\] \['"${sgr[0]}"'\]'
}

## Define function to set the secondary prompt
PS2() {
  PS2='\
\['"${sgr[N]}${sgr[B]}"'\]\
$(((LINENO - '$(("$1"))') / 10))\
$(((LINENO - '$(("$1"))') % 10))\
\['"${sgr[N]}"'\] \['"${sgr[0]}"'\]'
}

## Define function to set the pre-exec prompt
PS0() {
  PS0='\
\['"${sgr[N]}${sgr[B]}${sgr[D]}"'\]\
$(tput rep '"$(printf '%d' "'${1-"\#"}")"' "$(tput cols)")\
\['"${sgr[N]}"'\]\n\['"${sgr[0]}"'\]'
}

## Set the select-loop prompt
PS3='•◆ '

## Set the execution-trace prompt
PS4='\['"${sgr[N]}${sgr[B]}${sgr[D]}"'\]\
•\['"${sgr[N]}${sgr[B]}"'\]◆\['"${sgr[0]}"'\] '

## Define a command to evaluate before each primary prompt
PROMPT_COMMAND='PS0; PS1; PS2 $((LINENO));'

## Load any additional config
[[ -d ~/.bashrc.d ]] &&
  for _ in ~/.bashrc.d/?*; do
    [[ -f "$_" ]] && . "$_"
  done

## -- end --
