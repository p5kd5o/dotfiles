"" vimrc : vim startup script


"" Use vim defaults (instead of vi)
if &compatible
  set nocompatible
endif

"" If the +eval feature is missing, unset 'compatible'
silent! while 0
set nocompatible
silent! endwhile


"" Skip initialization for VSCode (for now)
if !exists('g:vscode')

  "" Always use UTF-8
  set encoding=utf-8


  "" Load filetype plugins & indentation style
  filetype plugin indent on

  "" Perform syntax highlighting
  if has("syntax")
    syntax enable
  endif


  "" Pathogen
  try
    execute pathogen#infect()
  catch /^Vim(execute):/
  endtry


  "" Spacing

  "" Insert spaces insted of tab characters
  set expandtab

  "" Number of columns reserved for line numbers
  set numberwidth=3

  "" Number of spaces to use for an indent
  set shiftwidth=2

  "" Number of spaces to insert for a tab
  set softtabstop=2

  "" Visual width of a tab character (ASCII 0x09)
  set tabstop=8

  "" Length past which lines will be broken automatically
  set textwidth=78


  "" Verbosity

  "" Display line numbers
  set number

  "" Display line numbers relative to current line
  set relativenumber

  "" Display cursor coordinates (e.g. LINE,COLUMN)
  set ruler

  "" Display most recent command below window
  set showcmd

  "" Briefly jump to match upon completing pair in 'matchpairs'
  set showmatch

  "" Never hide status line
  set laststatus=2

  "" Update terminal titles
  set title

  "" Define terminal titles
  let &titlestring = "%t%( [%M%R]%)%( (%{expand(\"%:p:~:h\")})%)%<"

  "" Show '@@@' for lines that don't fit and hex for nonprintable characters
  if v:version >= 800
    set display=truncate,uhex
  endif

  "" Apply ColorColumn highlighting to all columns beyond 'textwidth'
  function UpdateColorColumn()
    if (&textwidth)
      if (&number || &relativenumber)
        let l:columns = winwidth(0) - &textwidth - &numberwidth
      else
        let l:columns = winwidth(0) - &textwidth
      endif
      if (l:columns > 0)
        let &colorcolumn = join(map(range(1, l:columns), '"+" . v:val'), ',')
      else
        let &colorcolumn = ''
      endif
    endif
  endfunction
  call UpdateColorColumn()

  "" Update colorcolumn upon resizing of window
  autocmd VimResized * call UpdateColorColumn()


  "" Windows

  "" Split windows off toward to right
  set splitright

  "" Split windows off down below
  set splitbelow


  "" Buffers

  "" Re-read file if it was changed, unless it was deleted
  set autoread

  "" Hide closed buffers rather than unloading them
  set hidden


  "" Lines

  "" Do not wrap lines
  "set nowrap

  "" Break lines before window edge
  "set linebreak

  "" Indent wrapped lines
  "set breakindent

  "" Break lines at these characters
  "let &breakat = " \t;:"

  "" Prefix wrapped lines
  "let &showbreak = "> "


  "" Patterns

  "" Do not highlight search results
  set nohlsearch

  "" Search forward as pattern is typed
  set incsearch

  "" Ignore case by default
  set ignorecase

  "" Respect case if pattern contains uppercase
  set smartcase

  "" Additional bases recognized for increment/decrement
  set nrformats=bin,hex


  "" Cursor

  "" Attempt to preserve cursor position when moving linewise
  set nostartofline

  "" Allow backspacing over everything in insert mode
  set backspace=indent,eol,start

  "" Lines of padding between cursor and edge of window
  set scrolloff=3

  "" If 'nowrap' is set, minimum number of columnss to scroll at a time
  set sidescroll=1

  "" If 'nowrap' is set, columns of padding between cursor and edge of window
  set sidescrolloff=3

  "" Allow visual-block selection of empty columns
  set virtualedit=block


  "" Completion

  "" Enable command completion
  set wildmenu

  "" Ignore case for filename completion
  set wildignorecase

  "" Tweak insert-mode completion
  set completeopt=menu,preview,noselect

  "" Tweak command-mode completion
  set wildmode=list:longest,full

  "" Use <Left> / <Right> to move cursor instead of selecting completions
  cnoremap <Left>  <Space><BS><Left>
  cnoremap <Right> <Space><BS><Right>


  "" Key Timeout

  "" Time out on mappings and keycodes
  set timeout

  "" Time in ms to wait for completion of a mapping
  set timeoutlen=987

  "" Time in ms to wait for completion of a key code
  set ttimeoutlen=89


  "" History

  "" Number of search patterns and ``:'' commands to remember (max: 10000)
  set history=10000

  "" Number of modifications to remember for any given file
  set undolevels=2500

  "" Always save the whole buffer for undo when reloading it
  set undoreload=-1

  "" Max characters that may be typed between swapfile syncs
  set updatecount=80


  "" Swap / Undo

  "" Check undofile capability and use if using swapfile
  if has('persistent_undo')
    let &undofile = &swapfile
  endif

  "" Clear swap / undo directory preferences
  set directory=
  set   undodir=

  "" Append XDG_DATA_HOME if non-null
  if $XDG_DATA_HOME != ''
    set directory+=$XDG_DATA_HOME/vim/swap/
    set   undodir+=$XDG_DATA_HOME/vim/undo/
  endif

  "" Append XDG_CACHE_HOME if non-null
  if $XDG_CACHE_HOME != ''
    set directory+=$XDG_CACHE_HOME/vim/swap/
    set   undodir+=$XDG_CACHE_HOME/vim/undo/
  endif

  "" Append first element of 'runtimepath'
  if !empty(split(&runtimepath, ','))
    if &directory == ''
      let &directory = split(&runtimepath, ',')[0] . '/swap/'
    else
      let &directory .= ',' . split(&runtimepath, ',')[0] . '/swap/'
    endif
    if &undodir == ''
      let &undodir = split(&runtimepath, ',')[0] . '/undo/'
    else
      let &undodir .= ',' . split(&runtimepath, ',')[0] . '/undo/'
    endif
  endif

  "" Append default tmp directories
  set directory+=/var/tmp/,/tmp/
  set   undodir+=/var/tmp/,/tmp/

  "" Make the primary swap directory
  if !isdirectory(split(&directory, ',')[0])
    silent! call mkdir(split(&directory, ',')[0], 'p', 0700)
  endif

  "" Make the primary undo directory
  if !isdirectory(split(&undodir, ',')[0])
    silent! call mkdir(split(&undodir, ',')[0], 'p', 0700)
  endif


  "" Terminal

  "" F**k terminal bells
  set belloff=all


  "" Mouse

  "" Enable the mouse
  if has('mouse')
    set mouse=a
    if has('mouse_sgr')
      set ttymouse=sgr
    endif
  endif


  "" Colors

  "" Try to guess color capabilities
  if exists('+termguicolors')
    if $TERM =~ '\v^(putty|rxvt|screen)(-.*)?$'
      let &termguicolors = 0
    elseif ($TERM =~ '\v^(gnome|iterm|st|vte)(-.*)?$')
      let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
      let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
      let &termguicolors = 1
    elseif $TERM =~ '\v^(tmux|xterm)(-.*)?$'
          \ && $XTERM_VERSION != ''
          \ && $VTE_VERSION != ''
      let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
      let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
      let &termguicolors = 1
    endif
  endif

  "" Interpret the value of COLORTERM
  if $COLORTERM =~? '^\(truecolor\|24-bit\)$'
    let &t_Co = 16777216
  elseif $COLORTERM =~ '^[^[:digit:]]*256[^[:digit:]]*$'
    let &t_Co = 256
  endif

  "" Set a colorscheme
  if &t_Co >= 256
    let g:colorschemes = ['1989','desertink', 'lightning']
  else
    let g:colorschemes = ['elflord', 'peachpuff', 'delek', 'desert', 'default']
  endif
  function RotateColorscheme(n)
    try
      let l:start = index(g:colorschemes, g:colors_name)
    catch /^Vim(let)\=:E121/
      let l:start = -1
    endtry
    if (l:start > -1)
      let l:index = (l:start + a:n) % len(g:colorschemes)
    else
      let l:index = 0
    endif
    while (1)
      try
        execute join(['colorscheme', g:colorschemes[l:index]])
      catch /^Vim(colorscheme):/
        if (l:index + 1 != l:start + 1)
          let l:index = (l:index + 1) % len(g:colorschemes)
          continue
        endif
      endtry
      break
    endwhile
  endfunction
  call RotateColorscheme(1)
  nnoremap <silent><M-Up>
        \ :call RotateColorscheme(1)<CR>
  nnoremap <silent><M-Down>
        \ :call RotateColorscheme(-1)<CR>


  "" C / C++
  let g:c_comment_strings = 1 " Allow strings & numbers inside comments
  let g:c_gnu             = 1 " Highlight GNU specific items
  let g:c_space_errors    = 1 " Highlight space errors

  "" Set local options upon opening a C or C++ file
  autocmd FileType c,cpp
        \ setlocal cin noet sts=0 sw=8 ts=8|
        \ let &l:cino = ":0,(" . &l:tabstop


  "" Git

  "" Set textwidth for commit messages
  autocmd FileType gitcommit setlocal cc=50


  "" Markdown

  "" Set local options for markdown documents (e.g. README, etc.)
  autocmd FileType markdown
        \ setlocal cc=80 nonu nornu wrap lbr bri|
        \ let &l:brk = " \t!@?({+-*/;:,."


  "" Man

  "" Load the Man plugin
  runtime ftplugin/man.vim

  "" Use K to open man pages
  set keywordprg=:Man

  "" Set local options for man pages
  autocmd FileType man
        \ setlocal cc= noma nonu nornu nohid noswf noudf|
        \ autocmd VimResized <buffer> execute join([":Man", expand("%:t")])


  "" Python

  "" Set local options for python scripts
  autocmd FileType python setlocal et cc=80 sts=4 sw=4 ts=8

  "" Enable all available highlighting
  let g:python_highlight_all = 1

  "" Enable syntastic plugins
  "let g:syntastic_python_checkers = ['pep8', 'pylint', 'python3']
  let g:syntastic_python_checkers = ['pep8', 'python3']

  "" Set the default version for pyx commands
  if has('pythonx')
    if has('python3')
      set pyxversion=3
    elseif has('python2')
      set pyxversion=2
    endif
  endif


  "" Readline

  "" Highlight bash additions
  let g:readline_has_bash = 1


  "" Sed

  "" Highlight real tab characters in sed scripts
  let g:highlight_sedtabs = 1


  "" Sh

  "" Default highlighting for shell scripts
  let g:is_posix = 1

  "" Fold functions and if/do/for clauses
  let g:sh_fold_enabled = 3

  "" Relax error detection
  let g:sh_no_error = 1

  "" Set local options when opening a shell script
  autocmd FileType bash,sh,zsh setlocal et sts=2 sw=2 ts=8

  "" Set filetype to sh when editing a shell command line
  if $TMPDIR == ''
    autocmd BufRead /tmp/bash-fc.*
          \ setlocal ft=sh noswf noudf|
          \ let b:is_bash = 1|
          \ syntax enable
  else
    autocmd BufRead $TMPDIR/bash-fc.*
          \ setlocal ft=sh noswf noudf|
          \ let b:is_bash = 1|
          \ syntax enable
  endif


  "" help

  "" Set local options when opening a manpage
  autocmd FileType help setlocal noswf noudf


  "" -- CtrlSpace
  "
  let g:CtrlSpaceDefaultMappingKey = "<C-Space>"

  "" Syntastic

  let g:syntastic_always_populate_loc_list = 1
  let g:syntastic_auto_loc_list = 0
  let g:syntastic_check_on_open = 0


  "" Airline / Promptline / Tmuxline

  "" Airline theme settings
  let g:airline_theme = 'biogoo'
  "let g:airline_theme = 'tomorrow'
  "let g:airline_theme = 'kolor'
  "let g:airline_theme = 'atomic'
  let g:airline_powerline_fonts = 1

  "" Airline general settings
  "let g:airline_highlighting_cache = 0

  "" Airline extension whitelist
  "let g:airline_extensions = ['branch', 'syntastic', 'tabline']

  "" Branch extension settings
  "let g:airline#extensions#branch#format = 2

  "" Tabline extenstion settings
  let g:airline#extensions#tabline#enabled = 0
  let g:airline#extensions#tabline#formatter = 'unique_tail_improved'
  let g:airline#extensions#tabline#show_tabs = 1

  "" Airline symbol settings
  if !exists('g:airline_symbols')
    let g:airline_symbols = {}
  endif
  let g:airline_symbols.branch      = ''
  "let g:airline_symbols.branch      = ''
  let g:airline_symbols.crypt       = ''
  let g:airline_symbols.dirty       = ''
  "let g:airline_symbols.dirty       = ''
  "let g:airline_symbols.dirty       = ''
  let g:airline_symbols.ellipsis    = ''
  let g:airline_symbols.keymap      = ''
  "let g:airline_symbols.keymap      = ''
  "let g:airline_symbols.keymap      = ''
  "let g:airline_symbols.linenr      = ''
  let g:airline_symbols.linenr      = ''
  "let g:airline_symbols.linenr      = ''
  "let g:airline_symbols.linenr      = ''
  "let g:airline_symbols.linenr      = ''
  "let g:airline_symbols.maxlinenr   = ''
  "let g:airline_symbols.maxlinenr   = ''
  "let g:airline_symbols.maxlinenr   = ''
  let g:airline_symbols.maxlinenr   = ''
  let g:airline_symbols.modified    = '±'
  "let g:airline_symbols.modified    = ''
  "let g:airline_symbols.notexists   = ''
  let g:airline_symbols.notexists   = ''
  let g:airline_symbols.readonly    = ''
  "let g:airline_symbols.paste       = ''
  let g:airline_symbols.paste       = ''
  let g:airline_symbols.space       = ' '
  "let g:airline_symbols.spell       = ''
  let g:airline_symbols.spell       = ''
  let g:airline_symbols.whitespace  = ''


  "" Mappings

  "" Set a key to act as <leader> in mappings
  let g:mapleader = ','

  "" Create tab
  nnoremap <silent><leader>c
        \ :tabnew<CR>
  "" Next tab
  nnoremap <silent><leader>n
        \ :tabnext<CR>
  nnoremap <silent><M-Right>
        \ :tabnext<CR>
  "" Previous tab
  nnoremap <silent><leader>p
        \ :tabprev<CR>
  nnoremap <silent><M-Left>
        \ :tabprev<CR>
  "" Destroy tab
  nnoremap <silent><leader>x
        \ :tabprev<CR>

  "" F6: Toggle search highlighting
  nnoremap <silent><F6> :setlocal hlsearch!<CR>

  "" F7: Toggle syntax highlighting
  nnoremap <silent><F7>
        \ :if exists('g:syntax_on')<Bar>
        \ syntax off<Bar>
        \ else<Bar>
        \ syntax enable<Bar>
        \ endif<CR>

  "" F8: Toggle line numbers
  nnoremap <silent><F8> :let &l:nu = !&l:nu<Bar>let &l:rnu = &l:nu<CR>

  "" F9: Toggle paste mode
  nnoremap <silent><F9> :setlocal paste!<CR>

  "" Insert a shebang as the first line
  autocmd FileType * nnoremap <silent><leader>#!
        \ ggI<C-R>=
        \ substitute(&filetype, "..*", "#!" . exepath(&filetype) . "\\r", "")<CR>
        \ <ESC>``

  "" Search forward for the current visual selection
  "" Note: Jumping to a tag does not set the current search pattern
  vnoremap <silent> *
        \ :<C-U>let old_reg=getreg('"')<Bar>
        \ let old_regtype=getregtype('"')<CR>
        \ gvy/<C-R><C-R>=
        \ substitute(escape(@",'/\.*$^~['),'\_s\+','\\_s\\+','g')<CR><CR>
        \ gV:call setreg('"',old_reg,old_regtype)<CR>

  "" Search backward for the current visual selection
  "" Note: Jumping to a tag does not set the current search pattern
  vnoremap <silent> #
        \ :<C-U>let old_reg=getreg('"')<Bar>
        \ let old_regtype=getregtype('"')<CR>
        \ gvy?<C-R><C-R>=
        \ substitute(escape(@",'?\.*$^~['),'\_s\+','\\_s\\+','g')<CR><CR>
        \ gV:call setreg('"',old_reg,old_regtype)<CR>

  "" Map xterm sequences for Ctrl + Arrows
  map! <ESC>[1;5A <C-Up>
  map! <ESC>[1;5B <C-Down>
  map! <ESC>[1;5C <C-Right>
  map! <ESC>[1;5D <C-Left>
  nmap <ESC>[1;5A <C-Up>
  nmap <ESC>[1;5B <C-Down>
  nmap <ESC>[1;5C <C-Right>
  nmap <ESC>[1;5D <C-Left>
  vmap <ESC>[1;5A <C-Up>
  vmap <ESC>[1;5B <C-Down>
  vmap <ESC>[1;5C <C-Right>
  vmap <ESC>[1;5D <C-Left>

  "" Map xterm sequences for Alt + Arrows
  map! <ESC>[1;3A <M-Up>
  map! <ESC>[1;3B <M-Down>
  map! <ESC>[1;3C <M-Right>
  map! <ESC>[1;3D <M-Left>
  nmap <ESC>[1;3A <M-Up>
  nmap <ESC>[1;3B <M-Down>
  nmap <ESC>[1;3C <M-Right>
  nmap <ESC>[1;3D <M-Left>
  vmap <ESC>[1;3A <M-Up>
  vmap <ESC>[1;3B <M-Down>
  vmap <ESC>[1;3C <M-Right>
  vmap <ESC>[1;3D <M-Left>

  "" Finalize Configuration

  "" Allow options to be set from a modeline
  set modeline

  "" Restrict editor if SWIM owns this file (should be last in vimrc)
  set secure

endif
