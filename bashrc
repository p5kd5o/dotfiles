## ~/.bashrc : bash configuration for interactive shells
## bash 4.4
 

## Is this an interactive shell? If not, stop.
[[ $- != *i* ]] && return 0


## If DISPLAY is non-null, refresh LINES and COLUMNS after each command
[[ -n ${DISPLAY} ]] && shopt -s checkwinsize

## Initialize LINES and COLUMNS by sending SIGWINCH to the current shell
kill -s 28 "$$"


  
{ ## Try to set GPG_TTY to the current tty, assuming there is one
  [[ ${GPG_TTY@a} != *r* ]] && command -pv tty && GPG_TTY="$(command -p tty)"
  
  ## Declare GPG_TTY readonly and export it to the environment
  declare -rx GPG_TTY

  ## Refresh gpg-agent in case the user has switched to an Xsession
  command -p gpg-connect-agent updatestartuptty /bye

} 1>/dev/null 2>&1



## Functions, cmd substitutions, and subshells inherit traps on 'ERR' 
set -o errtrace


## Require the >| operator to overwrite existing files by redirection
set -o noclobber


## If the name of a directory is given as a command, pass it to cd
shopt -s autocd


## Check that a command found in the hashtable exists before running it
shopt -s checkhash


## Show jobs before exiting and require confirmation if any are running
shopt -s checkjobs


## Attempt to save each multiline command as a single history entry
shopt -s cmdhist


## Expand the name of a directory upon performing filename completion
shopt -s direxpand


## Attempt to correct mispelled directory names during word completion
shopt -s dirspell


## Enable extended pattern matching features
shopt -s extglob


## Let ``**`` match all files and 0 or more directories and subdirectories
shopt -s globstar


## Send SIGHUP(1) to all jobs when an interactive login shell exits
shopt -s huponexit


## Append to the history file instead of overwriting it
shopt -s histappend


## If using rl, allow user to re-edit a failed history substitution
shopt -s histreedit


## If using rl, load history substitutions into the editing buffer
shopt -s histverify


## Command substitutions inherit the value of the 'errexit' option
shopt -s inherit_errexit


## If job control is off, run the last cmd of a pipeline in the current shell
shopt -s lastpipe


## With 'cmdhist' enabled, save multiline commands with embedded newlines
shopt -s lithist



## Ignore shared object libraries when searching for executables
EXECIGNORE='/**/lib?(32|64)/**/*.@(dll|so*(.+([[:digit:]])))'

## Ignore paths ending at an instance of "." or ".."
GLOBIGNORE='*(?(.)*/).?(.)*(/)'

## Setting GLOBIGNORE enables 'dotglob' so disable it to go back to normal
shopt -u dotglob



## Declare namerefs to XDG dirs so I can avoid typing those long names
declare -n datadir='XDG_DATA_HOME'
declare -n confdir='XDG_CONFIG_HOME'
declare -n cachedir='XDG_CACHE_HOME'
declare -n runtimedir='XDG_RUNTIME_DIR'



## Erase duplicate entries from the history
HISTCONTROL='erasedups'

## If 'extglob' is on, ignore dups regardless of surrounding whitespace
HISTIGNORE='*([[:blank:]])&*([[:blank:]])'

## Configure the location of the history
if [[ -n ${XDG_DATA_HOME} ]] && mkdir -p -m 700 "${XDG_DATA_HOME}/bash"; then

  HISTFILE="${XDG_DATA_HOME}/bash/history"

elif [[ -n ${HOME} ]]; then

  if mkdir --parents --mode=700 "${HOME}/.local/share/bash"; then
    HISTFILE="${HOME}/.local/share/bash/history"

  else
    HISTFILE="${HOME}/.bash_history"
  fi

else
  mktemp --tmpdir="${XDG_RUNTIME_DIR}" "$$-bash_history.XXXXXXXX"

fi



## Limit depth of paths generated by '\w' during prompt expansion
PROMPT_DIRTRIM=4


## Create an array to store terminal info
declare -A ti=( )


## Define function to set the primary prompt
function PS1() {
  PS1=\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
'\['"${ti['bold']:="$(tput bold)"}"'\]'\
'\['"${ti['dim']:="$(tput dim)"}"'\]'\
'\['"$1"'\]'\
'$(tput dl1; printf %.s— {1..'"$((COLUMNS?(COLUMNS):"$(tput cols)"))"'})'\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
'\n'\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
'\['"${ti['bold']:="$(tput bold)"}"'\]'\
'\u'\
'\['"${ti['dim']:="$(tput dim)"}"'\]'\
'@'\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
'\['"${ti['bold']:="$(tput bold)"}"'\]'\
'\h'\
'\['"${ti['dim']:="$(tput dim)"}"'\]'\
':'\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
'\['"${ti['bold']:="$(tput bold)"}"'\]'\
'\w'\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
'\n'\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
'\['"${ti['bold']:="$(tput bold)"}"'\]'\
'\D{%A %d %B %Y %I:%M %p}'\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
'\n'\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
'\['"${ti['bold']:="$(tput bold)"}"'\]'\
'\['"${ti['dim']:="$(tput dim)"}"'\]'\
'\['"$1"'\]'\
'\$λ'\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
' '
}


## Define function to set the secondary prompt
function PS2() {
  PS2=\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
'\['"${ti['bold']:="$(tput bold)"}"'\]'\
'\['"${ti['dim']:="$(tput dim)"}"'\]'\
'\['"$1"'\]'\
'$(( (LINENO - '"$(( BASH_LINENO[-1] ))"') / 10 ))'\
'$(( (LINENO - '"$(( BASH_LINENO[-1] ))"') % 10 ))'\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
' '
}


## Define function to set the select prompt
function PS3() {
   PS3="${PS3:-"•>"}"
}


## Define function to set the execution-trace prompt
function PS4() {
  PS4=\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
'\['"${ti['bold']:="$(tput bold)"}"'\]'\
'\['"${ti['dim']:="$(tput dim)"}"'\]'\
'•'\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
'\['"${ti['bold']:="$(tput bold)"}"'\]'\
'>'\
'\['"${ti['sgr0']:="$(tput sgr0)"}"'\]'\
' '
}


function setPS() {
  ## Update the prompt strings before printing PS1
  if [[ $(( $1 && ${ti[colors]:=$(tput colors)} )) -eq 1 ]]; then

    set -- "$(tput setaf "$(( ($1 - 1) % 6 + 1 ))")"

  else

    set --

  fi 2>/dev/null

  PS1 "$1"
  PS2 "$1"
  PS3 "$1"
  PS4 "$1"
}


PROMPT_COMMAND='setPS "$?"'


## Set terminal window titles
case ${TERM} in
  xterm*|rxvt*|urxvt*|Eterm|aterm|kterm|gnome*)
    PROMPT_COMMAND+=${PROMPT_COMMAND:+; }\
'printf "\033]0;%s@%s:%s\007" "${USER}" "${HOSTNAME%%.*}" "${PWD/##${HOME}/\~}"'
    ;;
  screen*|tmux*)
    PROMPT_COMMAND+=${PROMPT_COMMAND:+; }\
'printf "\033_%s@%s:%s\033\\" "${USER}" "${HOSTNAME%%.*}" "${PWD/##${HOME}/\~}"'
    ;;
esac


## Load any additional profile config
if [[ -d ~/.bashrc.d ]]; then
  for _ in ~/.bashrc.d/*; do
    if [[ -f $_ ]]; then
      . "$_"
    fi
  done
fi
